{
	"user": {
		"prefix": "user",
		"body": [
			"/*",
			"** VS Code ユーザースニペット一覧 **",
			"https://github.com/tkmst201/Library の抜粋 + Utility",
			"",
			"last-update: ???",
			"最新版はこちら: https://github.com/tkmst201/Library/blob/master/cpp.json",
			"手動で作成しているので更新し忘れがあるかもしれません",
			"",
			"# Utility (git で管理していない詰め合わせ)",
			"2020/11/26 template: デフォルト実装",
			"2019/11/09 db: if (debug) {}",
			"2020/11/26 pyn: Yes No 出力",
			"2020/08/01 fori: for (i = 0; i < n; ++i) {}",
			"2020/08/01 forr: for (i = n - 1; i >= 0; --i) {}",
			"2020/09/04 compress: 座標圧縮 O(NlogN)", // TODO: compress: cx を生成して返すように変更
			"2020/11/07 compress2: 2 つの vector を合わせた座標圧縮 O(NlogN)", // TODO: compress2: cx を生成して返すように変更
			"2020/11/10 gcd：最大公約数",
			"2020/11/10 lcm：最小公倍数",
			"2020/11/11 prime_factorization: 素因数分解 O(√N)", // TODO: prime_factorization: より高速なものに変更
			"2020/12/09 find_divisor: 約数列挙 O(√N)", // TODO: find_divisor: 整理して git で管理する
			"2020/11/11 sieve: 素数列挙(エラトステネスの篩) O(NloglogN)",
			"2020/11/11 sieve_smallest_prime_factor: [i] := i の最小の素因数 となるようなテーブルを作成 O(n loglog n)", // TODO: 線形篩に変更? 高速化できるか調べる
			"2020/11/11 fast_prime_factorization: smallest_prime_factor テーブルを用いて素因数分解を行う O(log n)",
			"",
			"# DataStructure",
			"2021/06/05 SegmentTree: セグメント木",
			"2021/06/05 LazySegmentTree: 遅延伝搬セグ木",
			"2021/06/05 BinaryIndexedTree: BIT",
			"2021/06/05 UnionFind: UnionFind",
			"2021/06/05 AVL_Tree: AVL 木 (平衡二分探索木)",
			"",
			"# GraphTheory",
			"2021/06/05 HeavyLightDecomposition: 重軽分解(LCA 構築: Θ(n loglog n), クエリ: O(loglog n))",
			"2021/06/05 StronglyConnectedComponents: 強連結成分分解",
			"",
			"# Mathematics",
			"2021/06/05 ModInt: 剰余演算",
			"2021/06/05 RuntimeModInt: 実行時 mod 指定 ModInt",
			"2021/06/05 Combination: 組み合わせ, 階乗, 階乗逆元, 逆元 (動的構築)",
			"2021/06/05 euclid: ユークリッドの互除法関連関数詰め合わせ (gcd, lcm, ext_gcd)",
			"2021/06/05 mod_pow_inv: mod のべきや逆元 (mod_pow, mod_inv)",
			"2021/06/05 chinese_remainder: 中国剰余定理 (ext_gcd 付き)",
			"2021/06/05 Matrix: 行列",
			"2020/11/02 Polynomial: 多項式と 1 次式の乗除(削除予定)",
			"",
			"# Convolution",
			"2021/06/05 FastFourierTransform: 実数の畳み込み",
			"2021/06/05 NumberTheoreticTransform: 特別な法のもとでの畳み込み",
			"",
			"# String",
			"2020/08/22 RollingHash: ローリングハッシュ",
			"2020/08/25 SuffixArray: SuffixArray(SA-IS, LCP)",
			"*/\n",
		],
		"description": [
			"ユーザスニペット一覧",
		]
	},
	
	
	/* Utility */
	"template": {
		"prefix": "template",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define FOR(i,a,b) for(int i=(a);i<(b);++i)",
			"#define REP(i,n) FOR(i,0,n)",
			"#define ALL(v) begin(v),end(v)",
			"template<typename A, typename B> inline bool chmax(A & a, const B & b) { if (a < b) { a = b; return true; } return false; }",
			"template<typename A, typename B> inline bool chmin(A & a, const B & b) { if (a > b) { a = b; return true; } return false; }",
			"using ll = long long;",
			"using pii = pair<int, int>;",
			"constexpr ll INF = 1ll<<30;",
			"constexpr ll longINF = 1ll<<60;",
			"constexpr ll MOD = 1000000007;",
			"constexpr bool debug = false;",
			"//---------------------------------//",
			"",
			"int main() {",
			"\t$0",
			"}",
		],
		"description": [
			"デフォルト実装",
			"2020/11/26",
		]
	},
	
	"debug_output": {
		"prefix": "db",
		"body": [
			"if (debug) {",
			"\t$0",
			"}"
		],
		"description": "デバッグ補助"
	},
	
	"forr": {
		"prefix": "forr",
		"body": "for (${1:int} ${2:i} = ${3:N - 1}; ${2:i} >= ${4:0}; --${2:i}) $0",
		"description": "2020/01/15"
	},
	
	"putsY/N": {
		"prefix": "pyn",
		"body": [
			"puts([&]() -> bool {",
			"\t$0",
			"}() ? \"Yes\": \"No\");",
		],
		"description": [
			"Yes No 出力",
			"2020/11/26"
		]
	},

	"fori": {
		"prefix": "fori",
		"body": "for (${1:int} ${2:i} = ${3:0}; ${2:i} < ${4:N}; ++${2:i}) $0",
		"description": "2020/01/15"
	},
	
	"compress": {
		"prefix": "compress",
		"body": [
			"auto compress = [](auto &&v, auto &&cv) -> void {",
			"\tfor (auto &&u : v) cv.emplace_back(u);",
			"\tcv.emplace_back(INF);",
			"\tcv.emplace_back(-INF);",
			"\tstd::sort(std::begin(cv), std::end(cv));",
			"\tcv.erase(std::unique(std::begin(cv), std::end(cv)), std::end(cv));",
			"\tfor (auto &&u : v) u = std::lower_bound(std::begin(cv), std::end(cv), u) - std::begin(cv);",
			"};\n",
		],
		"description": [
			"座標圧縮",
			"2020/09/04",
		]
	},
	
	"compress2": {
		"prefix": "compress2",
		"body": [
			"auto compress2 = [](auto &&v1, auto &&v2, auto &&cv) -> void {",
			"\tfor (auto &&u : v1) cv.emplace_back(u);",
			"\tfor (auto &&u : v2) cv.emplace_back(u);",
			"\tcv.emplace_back(INF);",
			"\tcv.emplace_back(-INF);",
			"\tstd::sort(std::begin(cv), std::end(cv));",
			"\tcv.erase(std::unique(std::begin(cv), std::end(cv)), std::end(cv));",
			"\tfor (auto &&u : v1) u = std::lower_bound(std::begin(cv), std::end(cv), u) - std::begin(cv);",
			"\tfor (auto &&u : v2) u = std::lower_bound(std::begin(cv), std::end(cv), u) - std::begin(cv);",
			"};\n",
		],
		"description": [
			"2 つの vector を合わせた座標圧縮",
			"2020/11/07",
		]
	},
	
	"gcd": {
		"prefix":"gcd",
		"body": [
			"ll gcd(ll a, ll b) {",
			"\tif (b == 0) return a;",
			"\treturn gcd(b, a % b);",
			"}\n",
		],
		"description": [
			"最大公約数",
			"2020/11/10",
		]
	},
	
	"lcm": {
		"prefix":"lcm",
		"body": [
			"ll lcm(ll a, ll b) {",
			"\treturn a / gcd(a, b) * b;",
			"}\n",
		],
		"description": [
			"最小公倍数",
			"2020/11/10",
		]
	},
	
	"prime_factorization": {
		"prefix": "prime_factorization",
		"body": [
			"std::vector<std::pair<ll, ll>> prime_factorization(ll n) {",
			"\tstd::vector<std::pair<ll, ll>> res;",
			"\tfor (ll i = 2; i * i <= n; i++) {",
			"\t\tif (n % i == 0) res.emplace_back(i, 1), n /= i;",
			"\t\twhile (n % i == 0) ++res.back().second, n /= i;",
			"\t}",
			"\tif (n > 1) res.emplace_back(n, 1);",
			"\treturn res;",
			"}",
		],
		"description": [
			"素因数分解 O(√N)",
			"2020/11/11",
		]
	},
	
	"find_divisor": {
		"prefix": "find_divisor",
		"body": [
			"std::vector<ll> find_divisor(ll n) {",
			"\tassert(n > 0);",
			"\tstd::vector<ll> divisor;",
			"\tll i = 1;",
			"\tfor (; i * i <= n; i++) if (n % i == 0) divisor.emplace_back(i);",
			"\tint p = divisor.size() - 1;",
			"\tif (divisor[p] * divisor[p] == n) --p;",
			"\tfor (; p >= 0; --p) divisor.emplace_back(n / divisor[p]);",
			"\treturn divisor;",
			"}\n",
		],
		"description": [
			"約数列挙 O(√N)",
			"2020/12/09",
		]
	},
	
	"sieve": {
		"prefix": "sieve",
		"body": [
			"std::vector<int> sieve(int n) {",
			"\tstd::vector<int> res;",
			"\tstd::vector<bool> is_prime(n + 1, true);",
			"\tis_prime[0] = is_prime[1] = false;",
			"\tfor (int i = 2; i * i <= n; i++) {",
			"\t\tif (!is_prime[i]) continue;",
			"\t\tfor (int j = i * i; j <= n; j += i) is_prime[j] = false;",
			"\t}",
			"\tfor (int i = 2; i <= n; ++i) if (is_prime[i]) res.emplace_back(i);",
			"\treturn res;",
			"}",
		],
		"description": [
			"素数列挙(エラトステネスの篩)",
			"2020/11/11",
		]
	},
	
	"sieve_smallest_prime_factor": {
		"prefix": "sieve_smallest_prime_factor",
		"body": [
			"std::vector<int> sieve_smallest_prime_factor(int n) {",
			"\tassert(n >= 0);",
			"\tstd::vector<int> res(n + 1);",
			"\tstd::iota(begin(res), end(res), 0);",
			"\t",
			"\tfor (int i = 2; i * i <= n; ++i) {",
			"\t\tif (res[i] < i) continue;",
			"\t\tfor (int j = i * i; j <= n; j += i) {",
			"\t\t\tif (res[j] == j) res[j] = i;",
			"\t\t}",
			"\t}",
			"\t",
			"\treturn res;",
			"}\n",
		],
		"description": [
			"[i] := i の最小の素因数 となるようなテーブルを作成 O(n loglog n)",
			"2020/11/11",
		]
	},
	
	"fast_prime_factorization": {
		"prefix": "fast_prime_factorization",
		"body": [
			"std::vector<std::pair<int, int>> fast_prime_factorization(int n, const std::vector<int> & smallest_prime_factor) {",
			"\tassert(n >= 0);",
			"\tassert(n <= smallest_prime_factor.size());",
			"\tstd::vector<std::pair<int, int>> res;",
			"\tfor (; n > 1; n /= smallest_prime_factor[n]) {",
			"\t\tif (res.empty() || res.back().first != smallest_prime_factor[n]) res.emplace_back(smallest_prime_factor[n], 1);",
			"\t\telse ++res.back().second;",
			"\t}",
			"\treturn res;",
			"}\n",
		],
		"description": [
			"smallest_prime_factor テーブルを用いて素因数分解を行う O(log n)",
			"2020/11/11",
		]
	},

	
	/* DataStructure */
	"SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/DataStructure/SegmentTree.hpp",
			" */",
			"template<typename T>",
			"struct SegmentTree {",
			"\tusing value_type = T;",
			"\tusing const_reference = const value_type &;",
			"\tusing F = std::function<value_type (const_reference, const_reference)>;",
			"\tusing size_type = std::size_t;",
			"\t",
			"private:",
			"\tsize_type n, n_;",
			"\tvalue_type id_elem;",
			"\tF f;",
			"\tstd::vector<value_type> node;",
			"\t",
			"public:",
			"\tSegmentTree() = default;",
			"\t",
			"\tSegmentTree(size_type n, const_reference id_elem, const F & f)",
			"\t\t: n(n), id_elem(id_elem), f(f) {",
			"\t\tn_ = 1;",
			"\t\twhile (n_ < n) n_ <<= 1;",
			"\t\tnode.assign(2 * n_, id_elem);",
			"\t}",
			"\t",
			"\tSegmentTree(const std::vector<value_type> & v, const_reference id_elem, const F & f)",
			"\t\t: SegmentTree(v.size(), id_elem, f) {",
			"\t\tfor (size_type i = 0; i < v.size(); ++i) node[i + n_] = v[i];",
			"\t\tfor (size_type i = n_ - 1; i > 0; --i) node[i] = f(node[i << 1], node[i << 1 | 1]);",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvoid set(size_type i, const_reference x) noexcept {",
			"\t\tassert(i < size());",
			"\t\tnode[i += n_] = x;",
			"\t\twhile (i > 1) {",
			"\t\t\ti >>= 1;",
			"\t\t\tnode[i] = f(node[i << 1], node[i << 1 | 1]);",
			"\t\t}",
			"\t}",
			"\t",
			"\tconst_reference get(size_type i) const noexcept {",
			"\t\tassert(i < size());",
			"\t\treturn node[i + n_];",
			"\t}",
			"\t",
			"\tvalue_type fold(size_type l, size_type r) const noexcept {",
			"\t\tassert(l <= r);",
			"\t\tassert(r <= size());",
			"\t\tvalue_type lv = id_elem, rv = id_elem;",
			"\t\tfor (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {",
			"\t\t\tif (l & 1) lv = f(lv, node[l++]);",
			"\t\t\tif (r & 1) rv = f(node[r - 1], rv);",
			"\t\t}",
			"\t\treturn f(lv, rv);",
			"\t}",
			"\t",
			"\tvalue_type fold_all() const noexcept {",
			"\t\treturn node[1];",
			"\t}",
			"\t",
			"\tsize_type max_right(size_type l, std::function<bool (const_reference)> g) const noexcept {",
			"\t\tassert(l <= size());",
			"\t\tassert(g(id_elem));",
			"\t\tif (l == size()) return size();",
			"\t\tl += n_;",
			"\t\tvalue_type sum = id_elem;",
			"\t\twhile (true) {",
			"\t\t\twhile (~l & 1) l >>= 1;",
			"\t\t\tconst value_type nex_sum = f(sum, node[l]);",
			"\t\t\tif (g(nex_sum)) { sum = nex_sum; ++l; }",
			"\t\t\telse break;",
			"\t\t\tif ((l & -l) == l) return size();",
			"\t\t}",
			"\t\twhile (l < n_) {",
			"\t\t\tconst value_type nex_sum = f(sum, node[l << 1]);",
			"\t\t\tl <<= 1;",
			"\t\t\tif (g(nex_sum)) { sum = nex_sum; l |= 1; }",
			"\t\t}",
			"\t\treturn l - n_;",
			"\t}",
			"\t",
			"\tsize_type min_left(size_type r, std::function<bool (const_reference)> g) const noexcept {",
			"\t\tassert(r <= size());",
			"\t\tassert(g(id_elem));",
			"\t\tif (r == 0) return 0;",
			"\t\tr += n_;",
			"\t\tvalue_type sum = id_elem;",
			"\t\twhile (true) {",
			"\t\t\t--r;",
			"\t\t\twhile (r > 1 && (r & 1)) r >>= 1;",
			"\t\t\tconst value_type nex_sum = f(node[r], sum);",
			"\t\t\tif (g(nex_sum)) sum = nex_sum;",
			"\t\t\telse break;",
			"\t\t\tif ((r & -r) == r) return 0;",
			"\t\t}",
			"\t\twhile (r < n_) {",
			"\t\t\tconst value_type nex_sum = f(node[r << 1 | 1], sum);",
			"\t\t\tr <<= 1;",
			"\t\t\tif (!g(nex_sum)) r |= 1;",
			"\t\t\telse sum = nex_sum;",
			"\t\t}",
			"\t\treturn r + 1 - n_;",
			"\t}",
			"};",
		],
		"description": ""
	},
	
	"LazySegmentTree": {
		"prefix": "LazySegmentTree",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/DataStructure/LazySegmentTree.hpp",
			" */",
			"template<typename T, typename E>",
			"struct LazySegmentTree {",
			"\tusing value_type = T;",
			"\tusing lazy_type = E;",
			"\tusing size_type = std::size_t;",
			"\tusing F = std::function<value_type (const value_type &, const value_type &)>;",
			"\tusing G = std::function<value_type (const value_type &, const lazy_type &)>;",
			"\tusing H = std::function<lazy_type (const lazy_type &, const lazy_type &)>;",
			"\tusing P = std::function<lazy_type (const lazy_type &, size_type)>;",
			"\t",
			"private:",
			"\tsize_type n, n_, n_log;",
			"\tvalue_type id_node;",
			"\tlazy_type id_lazy;",
			"\tF f;",
			"\tG g;",
			"\tH h;",
			"\tP p;",
			"\tstd::vector<value_type> node;",
			"\tstd::vector<lazy_type> lazy;",
			"",
			"public:",
			"\tLazySegmentTree(size_type n, const value_type & id_node, const lazy_type & id_lazy, const F & f, const G & g, const H & h, const P & p = [](const lazy_type & e, size_type k) { return e; })",
			"\t\t\t: n(n), id_node(id_node), id_lazy(id_lazy), f(f), g(g), h(h), p(p) {",
			"\t\tn_ = 1;",
			"\t\tn_log = 0;",
			"\t\twhile (n_ < n) n_ <<= 1, ++n_log;",
			"\t\tnode.assign(2 * n_, id_node);",
			"\t\tlazy.assign(2 * n_, id_lazy);",
			"\t}",
			"\t",
			"\tLazySegmentTree(const std::vector<value_type> & v, const value_type & id_node, const lazy_type & id_lazy, const F & f, const G & g, const H & h, const P & p = [](const lazy_type & a, size_type l) { return a; })",
			"\t\t\t: LazySegmentTree(v.size(), id_node, id_lazy, f, g, h, p) {",
			"\t\tfor (size_type i = 0; i < v.size(); ++i) node[i + n_] = v[i];",
			"\t\tfor (size_type i = n_ - 1; i > 0; --i) node[i] = f(node[i << 1], node[i << 1 | 1]);",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvoid set(size_type k, const value_type & x) noexcept {",
			"\t\tassert(k < size());",
			"\t\tk += n_;",
			"\t\tthrust(k);",
			"\t\tnode[k] = x;",
			"\t\tlazy[k] = id_lazy;",
			"\t\trecalc(k);",
			"\t}",
			"\t",
			"\tvalue_type get(size_type k) noexcept {",
			"\t\tassert(k < size());",
			"\t\tk += n_;",
			"\t\tthrust(k);",
			"\t\treturn reflect(k, 1);",
			"\t}",
			"\t",
			"\tvoid update(size_type l, size_type r, const lazy_type & x) noexcept {",
			"\t\tassert(l <= r);",
			"\t\tassert(r <= size());",
			"\t\tif (l == r) return;",
			"\t\tl += n_;",
			"\t\tr += n_;",
			"\t\tthrust(l);",
			"\t\tthrust(r - 1);",
			"\t\tfor (size_type cl = l, cr = r; cl < cr; cl >>= 1, cr >>= 1) {",
			"\t\t\tif (cl & 1) lazy[cl] = h(lazy[cl], x), ++cl;",
			"\t\t\tif (cr & 1) --cr, lazy[cr] = h(lazy[cr], x);",
			"\t\t}",
			"\t\trecalc(l);",
			"\t\trecalc(r - 1);",
			"\t}",
			"\t",
			"\tvalue_type fold(size_type l, size_type r) noexcept {",
			"\t\tassert(l <= r);",
			"\t\tassert(r <= size());",
			"\t\tif (l == r) return id_node;",
			"\t\tl += n_;",
			"\t\tr += n_;",
			"\t\tthrust(l);",
			"\t\tthrust(r - 1);",
			"\t\tvalue_type vl = id_node, vr = id_node;",
			"\t\tfor (size_type w = 1; l < r; l >>= 1, r >>= 1, w <<= 1) {",
			"\t\t\tif (l & 1) vl = f(vl, reflect(l, w)), ++l;",
			"\t\t\tif (r & 1) --r, vr = f(reflect(r, w), vr);",
			"\t\t}",
			"\t\treturn f(vl, vr);",
			"\t}",
			"\t",
			"\tvalue_type fold_all() const {",
			"\t\treturn reflect(1, n_);",
			"\t}",
			"\t",
			"private:",
			"\tvalue_type reflect(size_type k, size_type w) const noexcept {",
			"\t\treturn lazy[k] == id_lazy ? node[k] : g(node[k], p(lazy[k], w));",
			"\t}",
			"\t",
			"\tvoid propagate(size_type k, size_type w) noexcept {",
			"\t\tif (lazy[k] == id_lazy) return;",
			"\t\tif ((k << 1) < node.size()) {",
			"\t\t\tlazy[k << 1] = h(lazy[k << 1], lazy[k]);",
			"\t\t\tlazy[k << 1 | 1] = h(lazy[k << 1 | 1], lazy[k]);",
			"\t\t}",
			"\t\tnode[k] = reflect(k, w);",
			"\t\tlazy[k] = id_lazy;",
			"\t}",
			"\t",
			"\tvoid recalc(size_type k) noexcept {",
			"\t\tfor (size_type i = k >> 1, cw = 1; i > 0; i >>= 1, cw <<= 1)",
			"\t\t\tnode[i] = f(reflect(i << 1, cw), reflect(i << 1 | 1, cw));",
			"\t}",
			"\t",
			"\tvoid thrust(size_type k) noexcept {",
			"\t\tfor (size_type i = n_log, w = n_; i > 0; --i, w >>= 1) propagate(k >> i, w);",
			"\t}",
			"};",
		],
		"description": ""
	},
	
	"BinaryIndexedTree": {
		"prefix": "BinaryIndexedTree",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/DataStructure/BinaryIndexedTree.hpp",
			" */",
			"template<typename T>",
			"struct BinaryIndexedTree {",
			"\tusing value_type = T;",
			"\tusing const_reference = const value_type &;",
			"\tusing F = std::function<value_type (const_reference, const_reference)>;",
			"\tusing size_type = std::size_t;",
			"\t",
			"private:",
			"\tsize_type n;",
			"\tvalue_type id_elem;",
			"\tF f;",
			"\tstd::vector<value_type> node;",
			"\t",
			"public:",
			"\tBinaryIndexedTree(size_type n, const_reference id_elem, const F & f)",
			"\t\t: n(n), id_elem(id_elem), f(f), node(n + 1, id_elem) {}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvoid add(size_type i, const_reference x) noexcept {",
			"\t\tassert(i < size());",
			"\t\t++i;",
			"\t\tfor (; i <= size(); i += i & -i) node[i] = f(node[i], x);",
			"\t}",
			"\t",
			"\tvalue_type sum(size_type i) const noexcept {",
			"\t\tassert(i <= size());",
			"\t\tvalue_type res = id_elem;",
			"\t\tfor (; i > 0; i -= i & -i) res = f(node[i], res);",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tsize_type lower_bound(const_reference x) const noexcept {",
			"\t\tsize_type res = 0;",
			"\t\tsize_type s = id_elem, w = 1;",
			"\t\twhile (w < size()) w <<= 1;",
			"\t\tfor (; w > 0; w >>= 1) {",
			"\t\t\tif (res + w <= size()) {",
			"\t\t\t\tvalue_type cur = f(s, node[res + w]);",
			"\t\t\t\tif (cur < x) {",
			"\t\t\t\t\tres += w;",
			"\t\t\t\t\ts = cur;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};",
		],
		"description": ""
	},
	
	"UnionFind": {
		"prefix": "UnionFind",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/DataStructure/UnionFind.hpp",
			" */",
			"struct UnionFind {",
			"\tusing size_type = std::size_t;",
			"\t",
			"private:",
			"\tsize_type n;",
			"\tstd::vector<int> dat;",
			"\t",
			"public:",
			"\texplicit UnionFind(size_type n) : n(n), dat(n, -1) {}",
			"\t",
			"\tsize_type size(size_type x) noexcept {",
			"\t\tassert(x < n);",
			"\t\treturn -dat[find(x)];",
			"\t}",
			"\t",
			"\tsize_type find(size_type x) noexcept {",
			"\t\tassert(x < n);",
			"\t\tif (dat[x] < 0) return x;",
			"\t\treturn dat[x] = find(dat[x]);",
			"\t}",
			"\t",
			"\tvoid unite(size_type x, size_type y) noexcept {",
			"\t\tassert(x < n);",
			"\t\tassert(y < n);",
			"\t\tx = find(x);",
			"\t\ty = find(y);",
			"\t\tif (x == y) return;",
			"\t\tif (dat[x] < dat[y]) std::swap(x, y);",
			"\t\tdat[y] += dat[x];",
			"\t\tdat[x] = y;",
			"\t}",
			"\t",
			"\tbool issame(size_type x, size_type y) noexcept {",
			"\t\tassert(x < n);",
			"\t\tassert(y < n);",
			"\t\treturn find(x) == find(y);",
			"\t}",
			"};",
		],
		"description": ""
	},
	
	"AVL_Tree": {
		"prefix": "AVL_Tree",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/DataStructure/AVL_Tree.hpp",
			" */",
			"template<typename T>",
			"struct AVL_Tree {",
			"\tusing size_type = std::size_t;",
			"\tusing value_type = T;",
			"\tusing const_reference = const value_type &;",
			"\t",
			"private:",
			"\tusing uint32 = std::uint32_t;",
			"\tusing int8 = std::int8_t;",
			"\t",
			"public:",
			"\tstruct Node;",
			"\tusing node_ptr = Node *;",
			"\tusing const_ptr = const Node * const;",
			"\tstruct Node {",
			"\t\tvalue_type val;",
			"\t\tnode_ptr par, child[2] {nullptr, nullptr};",
			"\t\tbool isr;",
			"\t\tint8 height[2] {};",
			"\t\tuint32 size[2] {};",
			"\t\tNode(const_reference val, node_ptr par, bool isr) : val(val), par(par), isr(isr) {}",
			"\t};",
			"\t",
			"private:",
			"\tsize_type n = 0;",
			"\tnode_ptr root = nullptr;",
			"\tnode_ptr e_ptr[2] {nullptr, nullptr};",
			"\t",
			"public:",
			"\tAVL_Tree() = default;",
			"\t",
			"\tAVL_Tree(const AVL_Tree & rhs) {",
			"\t\t*this = rhs;",
			"\t}",
			"\t",
			"\tAVL_Tree(AVL_Tree && rhs) {",
			"\t\t*this = std::forward<AVL_Tree>(rhs);",
			"\t}",
			"\t",
			"\t~AVL_Tree() {",
			"\t\tclear();",
			"\t}",
			"\t",
			"\tAVL_Tree & operator =(const AVL_Tree & rhs) {",
			"\t\tif (this != &rhs) {",
			"\t\t\tclear();",
			"\t\t\tauto dfs = [](auto self, const_ptr q, node_ptr r) -> node_ptr {",
			"\t\t\t\tif (!q) return nullptr;",
			"\t\t\t\tnode_ptr res = new Node(q->val, r, q->isr);",
			"\t\t\t\tfor (int i = 0; i < 2; ++i) {",
			"\t\t\t\t\tres->height[i] = q->height[i];",
			"\t\t\t\t\tres->size[i] = q->size[i];",
			"\t\t\t\t\tres->child[i] = self(self, q->child[i], res);",
			"\t\t\t\t}",
			"\t\t\t\treturn res;",
			"\t\t\t};",
			"\t\t\troot = dfs(dfs, rhs.root, nullptr);",
			"\t\t\tn = rhs.n;",
			"\t\t\te_ptr[0] = e_ptr[1] = root;",
			"\t\t\tif (root) for (int i = 0; i < 2; ++i) while (e_ptr[i]->child[i]) e_ptr[i] = e_ptr[i]->child[i];",
			"\t\t}",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tAVL_Tree & operator =(AVL_Tree && rhs) {",
			"\t\tif (this != &rhs) {",
			"\t\t\tclear();",
			"\t\t\tn = rhs.n;",
			"\t\t\trhs.n = 0;",
			"\t\t\troot = rhs.root;",
			"\t\t\trhs.root = nullptr;",
			"\t\t\tstd::copy(rhs.e_ptr, rhs.e_ptr + 2, e_ptr);",
			"\t\t\tstd::fill(rhs.e_ptr, rhs.e_ptr + 2, nullptr);",
			"\t\t}",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tbool empty() const noexcept {",
			"\t\treturn size() == 0;",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvoid clear() {",
			"\t\tif (!root) return;",
			"\t\tstd::stack<node_ptr> stk;",
			"\t\tstk.emplace(root);",
			"\t\twhile (!stk.empty()) {",
			"\t\t\tnode_ptr node = stk.top();",
			"\t\t\tstk.pop();",
			"\t\t\tif (node->child[0]) stk.emplace(node->child[0]);",
			"\t\t\tif (node->child[1]) stk.emplace(node->child[1]);",
			"\t\t\tdelete node;",
			"\t\t}",
			"\t\tn = 0;",
			"\t\troot = nullptr;",
			"\t\tstd::fill(e_ptr, e_ptr + 2, nullptr);",
			"\t}",
			"\t",
			"\tstd::vector<value_type> enumerate() const {",
			"\t\tstd::vector<value_type> elements;",
			"\t\telements.reserve(size());",
			"\t\tauto dfs = [&elements](auto self, const_ptr q) -> void {",
			"\t\t\tif (!q) return;",
			"\t\t\tself(self, q->child[0]);",
			"\t\t\telements.emplace_back(q->val);",
			"\t\t\tself(self, q->child[1]);",
			"\t\t};",
			"\t\tdfs(dfs, root);",
			"\t\treturn elements;",
			"\t}",
			"\t",
			"\tnode_ptr begin() const noexcept {",
			"\t\treturn e_ptr[0];",
			"\t}",
			"\t",
			"\tnode_ptr end() const noexcept {",
			"\t\treturn nullptr;",
			"\t}",
			"\t",
			"\tnode_ptr insert(const_reference x) {",
			"\t\tnode_ptr q = root, r = nullptr;",
			"\t\tbool ef[2] {}, d = false;",
			"\t\twhile (q) {",
			"\t\t\tr = q;",
			"\t\t\td = q->val <= x;",
			"\t\t\tq = q->child[d];",
			"\t\t\tef[!d] = true;",
			"\t\t}",
			"\t\tq = new Node(x, r, d);",
			"\t\t++n;",
			"\t\tif (!ef[0]) e_ptr[0] = q;",
			"\t\tif (!ef[1]) e_ptr[1] = q;",
			"\t\tif (r) {",
			"\t\t\tr->size[d] = 1;",
			"\t\t\tr->height[d] = 1;",
			"\t\t\tr->child[d] = q;",
			"\t\t\tupdate(r);",
			"\t\t}",
			"\t\telse root = q;",
			"\t\treturn q;",
			"\t}",
			"\t",
			"\tnode_ptr erase(const_reference x) noexcept {",
			"\t\tnode_ptr q = find(x);",
			"\t\tif (q == end()) return end();",
			"\t\treturn erase(q);",
			"\t}",
			"\t",
			"\tnode_ptr erase(node_ptr q) noexcept {",
			"\t\tif (!q) return end();",
			"\t\tconst node_ptr ret = next(q);",
			"\t\tif (q->child[0] && q->child[1]) {",
			"\t\t\tnode_ptr p = q->child[0];",
			"\t\t\twhile (p->child[1]) p = p->child[1];",
			"\t\t\tq->val = std::move(p->val);",
			"\t\t\tq = p;",
			"\t\t}",
			"\t\tif (e_ptr[0] == q) e_ptr[0] = next(q);",
			"\t\tif (e_ptr[1] == q) e_ptr[1] = prev(q);",
			"\t\tconst node_ptr r = q->par;",
			"\t\tif (q->child[0] || q->child[1]) {",
			"\t\t\tconst node_ptr p = q->child[0] ? q->child[0] : q->child[1];",
			"\t\t\tif (r) {",
			"\t\t\t\tr->size[q->isr] = q->size[p->isr];",
			"\t\t\t\tr->height[q->isr] = q->height[p->isr];",
			"\t\t\t\tr->child[q->isr] = p;",
			"\t\t\t\tp->par = r;",
			"\t\t\t\tp->isr = q->isr;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tp->par = nullptr;",
			"\t\t\t\troot = p;",
			"\t\t\t}",
			"\t\t}",
			"\t\telse if (r) {",
			"\t\t\tr->size[q->isr] = 0;",
			"\t\t\tr->height[q->isr] = 0;",
			"\t\t\tr->child[q->isr] = nullptr;",
			"\t\t}",
			"\t\telse root = nullptr;",
			"\t\tdelete q;",
			"\t\t--n;",
			"\t\tif (r) update(r);",
			"\t\treturn ret;",
			"\t}",
			"\t",
			"\tnode_ptr find(const_reference x) const noexcept {",
			"\t\tconst node_ptr q = lower_bound(x);",
			"\t\tif (q != end() && q->val != x) return end();",
			"\t\treturn q;",
			"\t}",
			"\t",
			"\tnode_ptr lower_bound(const_reference x) const noexcept {",
			"\t\tnode_ptr q = root;",
			"\t\tif (!q) return end();",
			"\t\twhile (q->child[q->val < x]) q = q->child[q->val < x];",
			"\t\tif (q->val < x) q = next(q);",
			"\t\treturn q;",
			"\t}",
			"\t",
			"\tnode_ptr upper_bound(const_reference x) const noexcept {",
			"\t\tnode_ptr q = root;",
			"\t\tif (!q) return end();",
			"\t\twhile (q->child[q->val <= x]) q = q->child[q->val <= x];",
			"\t\tif (q->val <= x) q = next(q);",
			"\t\treturn q;",
			"\t}",
			"\t",
			"\tsize_type count_less_than(const_reference x) const noexcept {",
			"\t\tsize_type res = 0;",
			"\t\tnode_ptr q = root;",
			"\t\twhile (q != nullptr) {",
			"\t\t\tbool r = q->val < x;",
			"\t\t\tif (r) res += q->size[0] + 1;",
			"\t\t\tq = q->child[r];",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tsize_type count_less_equal(const_reference x) const noexcept {",
			"\t\tsize_type res = 0;",
			"\t\tnode_ptr q = root;",
			"\t\twhile (q != nullptr) {",
			"\t\t\tbool r = q->val <= x;",
			"\t\t\tif (r) res += q->size[0] + 1;",
			"\t\t\tq = q->child[r];",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tsize_type count_greater_than(const_reference x) const noexcept {",
			"\t\treturn size() - count_less_equal(x);",
			"\t}",
			"\t",
			"\tsize_type count_greater_equal(const_reference x) const noexcept {",
			"\t\treturn size() - count_less_than(x);",
			"\t}",
			"\t",
			"\tsize_type count(const_reference x) const noexcept {",
			"\t\treturn count_less_equal(x) - count_less_than(x);",
			"\t}",
			"\t",
			"\tnode_ptr k_th_smallest(uint32 k) const noexcept {",
			"\t\tif (k == 0 || n < k) return end();",
			"\t\tnode_ptr q = root;",
			"\t\twhile (k != q->size[0] + 1) {",
			"\t\t\tif (k > q->size[0] + 1) k -= q->size[0] + 1, q = q->child[1];",
			"\t\t\telse q = q->child[0];",
			"\t\t}",
			"\t\treturn q;",
			"\t}",
			"\t",
			"\tnode_ptr k_th_largest(uint32 k) const noexcept {",
			"\t\tif (k == 0 || n < k) return end();",
			"\t\treturn k_th_smallest(n - k + 1);",
			"\t}",
			"\t",
			"\tnode_ptr next(node_ptr q) const noexcept {",
			"\t\treturn move(q, true);",
			"\t}",
			"\t",
			"\tnode_ptr prev(node_ptr q) const noexcept {",
			"\t\treturn move(q, false);",
			"\t}",
			"\t",
			"private:",
			"\tnode_ptr rotate(node_ptr q, bool d) noexcept {",
			"\t\tnode_ptr r = q->par, p = q->child[!d], b = p->child[d];",
			"\t\t(r ? r->child[q->isr] : root) = p;",
			"\t\tq->child[!d] = b;",
			"\t\tp->child[d] = q;",
			"\t\tif (b) {",
			"\t\t\tb->par = q;",
			"\t\t\tb->isr = !d;",
			"\t\t}",
			"\t\tp->par = r;",
			"\t\tp->isr = q->isr;",
			"\t\tq->par = p;",
			"\t\tq->isr = d;",
			"\t\tq->size[!d] = p->size[d];",
			"\t\tq->height[!d] = p->height[d];",
			"\t\tp->size[d] = q->size[0] + q->size[1] + 1;",
			"\t\tp->height[d] = std::max(q->height[0], q->height[1]) + 1;",
			"\t\treturn p;",
			"\t}",
			"\t",
			"\tvoid update(node_ptr q) noexcept {",
			"\t\tbool done = false;",
			"\t\twhile (true) {",
			"\t\t\tif (!done && std::abs(q->height[0] - q->height[1]) > 1) {",
			"\t\t\t\tconst bool d = q->height[0] > q->height[1];",
			"\t\t\t\tconst node_ptr p = q->child[!d];",
			"\t\t\t\tif (p->height[!d] < p->height[d]) rotate(p, !d);",
			"\t\t\t\tq = rotate(q, d);",
			"\t\t\t\tdone = true;",
			"\t\t\t}",
			"\t\t\tconst node_ptr r = q->par;",
			"\t\t\tif (!r) break;",
			"\t\t\tr->size[q->isr] = q->size[0] + q->size[1] + 1;",
			"\t\t\tr->height[q->isr] = std::max(q->height[0], q->height[1]) + 1;",
			"\t\t\tq = r;",
			"\t\t}",
			"\t}",
			"\t",
			"\tnode_ptr move(node_ptr q, bool d) const noexcept {",
			"\t\tif (q == end()) return e_ptr[!d];",
			"\t\tif (q == begin() && !d) return end();",
			"\t\tif (q->child[d]) for (q = q->child[d]; q->child[!d]; q = q->child[!d]);",
			"\t\telse {",
			"\t\t\twhile (q && (d ^ !q->isr)) q = q->par;",
			"\t\t\tif (q) q = q->par;",
			"\t\t}",
			"\t\treturn q;",
			"\t}",
			"};",
		],
		"description": ""
	},
	
	/* GraphTheory */
	"HeavyLightDecomposition": {
		"prefix": "HeavyLightDecomposition",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/GraphTheory/HeavyLightDecomposition.hpp",
			" */",
			"struct HeavyLightDecomposition {",
			"\tusing Graph = std::vector<std::vector<int>>;",
			"\t",
			"private:",
			"\tint n;",
			"\tstd::vector<int> par_;",
			"\tstd::vector<int> heavy_, head_, heavy_size_, heavy_depth_;",
			"\tstd::vector<int> tree_id_, roots_;",
			"\tstd::vector<int> in_, out_;",
			"\tstd::vector<std::vector<int>> par_dblng_;",
			"\tbool LCA;",
			"\t",
			"public:",
			"\tHeavyLightDecomposition(const Graph & g, bool LCA = false)",
			"\t\t: HeavyLightDecomposition(g, -1, LCA) {}",
			"\t",
			"\tHeavyLightDecomposition(const Graph & g, int root, bool LCA)",
			"\t\t: n(g.size()), par_(n, -1), heavy_(n, -1), tree_id_(n, -1), in_(n, -1), out_(n, -1), LCA(LCA) {",
			"\t\tstd::vector<int> sub_size(n, 0), next(n, -1);",
			"\t\tfor (int i = 0; i < n; ++i) {",
			"\t\t\tif (tree_id_[i] != -1) continue;",
			"\t\t\tif (root != -1 && i != root) continue;",
			"\t\t\ttree_id_[i] = roots_.size();",
			"\t\t\tstd::stack<int> stk;",
			"\t\t\tstk.emplace(i);",
			"\t\t\twhile (!stk.empty()) {",
			"\t\t\t\tconst int u = stk.top();",
			"\t\t\t\tstk.pop();",
			"\t\t\t\tif (sub_size[u]) {",
			"\t\t\t\t\tint mx_size = 0;",
			"\t\t\t\t\tfor (int v : g[u]) {",
			"\t\t\t\t\t\tif (v == par_[u]) continue;",
			"\t\t\t\t\t\tsub_size[u] += sub_size[v];",
			"\t\t\t\t\t\tif (mx_size < sub_size[v]) mx_size = sub_size[v], next[u] = v;",
			"\t\t\t\t\t}",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\t}",
			"\t\t\t\tsub_size[u] = 1;",
			"\t\t\t\tstk.emplace(u);",
			"\t\t\t\tfor (int v : g[u]) {",
			"\t\t\t\t\tassert(0 <= v && v < n);",
			"\t\t\t\t\tassert(v != u);",
			"\t\t\t\t\tif (v == par_[u]) continue;",
			"\t\t\t\t\tpar_[v] = u;",
			"\t\t\t\t\ttree_id_[v] = roots_.size();",
			"\t\t\t\t\tstk.emplace(v);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\troots_.emplace_back(i);",
			"\t\t}",
			"\t\tint euc = 0;",
			"\t\tfor (int r : roots_) {",
			"\t\t\theavy_[r] = head_.size();",
			"\t\t\thead_.emplace_back(r);",
			"\t\t\theavy_size_.emplace_back(1);",
			"\t\t\theavy_depth_.emplace_back(0);",
			"\t\t\tstd::stack<std::pair<int, int>> stk;",
			"\t\t\tstk.emplace(r, 0);",
			"\t\t\twhile (!stk.empty()) {",
			"\t\t\t\tconst auto [u, i] = stk.top();",
			"\t\t\t\tstk.pop();",
			"\t\t\t\tif (i < static_cast<int>(g[u].size())) {",
			"\t\t\t\t\tstk.emplace(u, i + 1);",
			"\t\t\t\t\tconst int v = g[u][i];",
			"\t\t\t\t\tif (v != par_[u] && v != next[u]) {",
			"\t\t\t\t\t\theavy_[v] = head_.size();",
			"\t\t\t\t\t\thead_.emplace_back(v);",
			"\t\t\t\t\t\theavy_size_.emplace_back(1);",
			"\t\t\t\t\t\theavy_depth_.emplace_back(heavy_depth_[heavy_[u]] + 1);",
			"\t\t\t\t\t\tstk.emplace(v, 0);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\tif (i == 0) {",
			"\t\t\t\t\tin_[u] = euc++;",
			"\t\t\t\t\tconst int v = next[u];",
			"\t\t\t\t\tif (v != -1) {",
			"\t\t\t\t\t\theavy_[v] = heavy_[u];",
			"\t\t\t\t\t\t++heavy_size_[heavy_[u]];",
			"\t\t\t\t\t\tstk.emplace(v, 0);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\tif (i == static_cast<int>(g[u].size())) out_[u] = euc;",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (!LCA) return;",
			"\t\tint max_depth = *std::max_element(begin(heavy_depth_), end(heavy_depth_));",
			"\t\tint lglg_n = 0;",
			"\t\twhile ((1 << lglg_n) <= max_depth) ++lglg_n;",
			"\t\tpar_dblng_.assign(lglg_n + 1, std::vector<int>(heavy_size(), -1));",
			"\t\tfor (int i = 0; i < heavy_size(); ++i) par_dblng_[0][i] = par_[head_[i]] == -1 ? head_[i] : par_[head_[i]];",
			"\t\tfor (int i = 0; i < lglg_n; ++i) {",
			"\t\t\tfor (int j = 0; j < heavy_size(); ++j) {",
			"\t\t\t\tpar_dblng_[i + 1][j] = par_dblng_[i][heavy_[par_dblng_[i][j]]];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\tint size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tint par(int v) const noexcept {",
			"\t\tassert(0 <= v && v < size());",
			"\t\treturn par_[v];",
			"\t}",
			"\t",
			"\tint tree_id(int v) const noexcept {",
			"\t\tassert(0 <= v && v < size());",
			"\t\treturn tree_id_[v];",
			"\t}",
			"\t",
			"\tint tree_cnt() const noexcept {",
			"\t\treturn roots_.size();",
			"\t}",
			"\t",
			"\tconst std::vector<int> & trees() const noexcept {",
			"\t\treturn roots_;",
			"\t}",
			"\t",
			"\tint heavy(int v) const noexcept {",
			"\t\tassert(0 <= v && v < size());",
			"\t\treturn heavy_[v];",
			"\t}",
			"\t",
			"\tint head(int k) const noexcept {",
			"\t\tassert(0 <= k && k < heavy_size());",
			"\t\treturn head_[k];",
			"\t}",
			"\t",
			"\tint heavy_size() const noexcept {",
			"\t\treturn head_.size();",
			"\t}",
			"\t",
			"\tint heavy_size(int k) const noexcept {",
			"\t\tassert(0 <= k && k < heavy_size());",
			"\t\treturn heavy_size_[k];",
			"\t}",
			"\t",
			"\tint heavy_depth(int k) const noexcept {",
			"\t\tassert(0 <= k && k < heavy_size());",
			"\t\treturn heavy_depth_[k];",
			"\t}",
			"\t",
			"\tint in(int v) const noexcept {",
			"\t\tassert(0 <= v && v < size());",
			"\t\treturn in_[v];",
			"\t}",
			"\t",
			"\tint out(int v) const noexcept {",
			"\t\tassert(0 <= v && v < size());",
			"\t\treturn out_[v];",
			"\t}",
			"\t",
			"\tconst std::vector<std::vector<int>> & par_dblng() const noexcept {",
			"\t\tassert(LCA);",
			"\t\treturn par_dblng_;",
			"\t}",
			"\t",
			"\tstd::pair<int, int> lca_heavy(int x, int y) const noexcept {",
			"\t\tassert(LCA);",
			"\t\tassert(0 <= x && x < size());",
			"\t\tassert(0 <= y && y < size());",
			"\t\tassert(tree_id_[x] == tree_id_[y]);",
			"\t\tif (heavy_[x] == heavy_[y]) return {x, y};",
			"\t\tconst bool isswap = heavy_depth_[heavy_[x]] < heavy_depth_[heavy_[y]];",
			"\t\tif (isswap) std::swap(x, y);",
			"\t\tconst int diff = heavy_depth_[heavy_[x]] - heavy_depth_[heavy_[y]];",
			"\t\tfor (int i = 0; i < static_cast<int>(par_dblng_.size()); ++i) if (diff >> i & 1) x = par_dblng_[i][heavy_[x]];",
			"\t\tif (heavy_[x] == heavy_[y]) return isswap ? std::make_pair(y, x) : std::make_pair(x, y);",
			"\t\tfor (int i = par_dblng_.size() - 1; i >= 0; --i) {",
			"\t\t\tconst int p1 = par_dblng_[i][heavy_[x]], p2 = par_dblng_[i][heavy_[y]];",
			"\t\t\tif (heavy_[p1] != heavy_[p2]) x = p1, y = p2;",
			"\t\t}",
			"\t\tx = par_dblng_[0][heavy_[x]];",
			"\t\ty = par_dblng_[0][heavy_[y]];",
			"\t\treturn isswap ? std::make_pair(y, x) : std::make_pair(x, y);",
			"\t}",
			"\t",
			"\tint lca(int x, int y) {",
			"\t\tassert(LCA);",
			"\t\tassert(0 <= x && x < size());",
			"\t\tassert(0 <= y && y < size());",
			"\t\tassert(tree_id_[x] == tree_id_[y]);",
			"\t\tconst auto [a, b] = lca_heavy(x, y);",
			"\t\treturn in_[a] < in_[b] ? a : b;",
			"\t}",
			"};",
		],
		"description": ""
	},
	
	"StronglyConnectedComponents": {
		"prefix": "StronglyConnectedComponents",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/GraphTheory/StronglyConnectedComponents.hpp",
			" */",
			"struct StronglyConnectedComponents {",
			"\tusing Graph = std::vector<std::vector<int>>;",
			"\t",
			"private:",
			"\tint n;",
			"\tstd::vector<int> rank_;",
			"\tstd::vector<std::vector<int>> rank_list_;",
			"\t",
			"public:",
			"\texplicit StronglyConnectedComponents(const Graph & g) : n(g.size()) {",
			"\t\tGraph rg(n);",
			"\t\tfor (int i = 0; i < n; ++i) {",
			"\t\t\tfor (int j : g[i]) {",
			"\t\t\t\tassert(0 <= j && j < n);",
			"\t\t\t\trg[j].emplace_back(i);",
			"\t\t\t}",
			"\t\t}",
			"\t\tstd::vector<bool> visited(n, false);",
			"\t\tstd::vector<int> num;",
			"\t\tauto dfs = [&](auto self, int u) -> void {",
			"\t\t\tvisited[u] = true;",
			"\t\t\tfor (int v : g[u]) if (!visited[v]) self(self, v);",
			"\t\t\tnum.emplace_back(u);",
			"\t\t};",
			"\t\tfor (int i = 0; i < n; ++i) if (!visited[i]) dfs(dfs, i);",
			"\t\tint cnt = 0;",
			"\t\tvisited.assign(n, false);",
			"\t\trank_.assign(n, -1);",
			"\t\tauto rdfs = [&](auto self, int u) -> void {",
			"\t\t\tvisited[u] = true;",
			"\t\t\trank_[u] = cnt;",
			"\t\t\tfor (int v : rg[u]) if (!visited[v]) self(self, v);",
			"\t\t};",
			"\t\tfor (int i = n - 1; i >= 0; --i) if (!visited[num[i]]) rdfs(rdfs, num[i]), ++cnt;",
			"\t\trank_list_.assign(cnt, {});",
			"\t\tfor (int i = 0; i < n; ++i) rank_list_[rank_[i]].emplace_back(i);",
			"\t}",
			"\t",
			"\tint size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tint scc_size() const noexcept {",
			"\t\treturn rank_list_.size();",
			"\t}",
			"\t",
			"\tint scc_size(int k) const noexcept {",
			"\t\tassert(0 <= k && k < scc_size());",
			"\t\treturn rank_list_[k].size();",
			"\t}",
			"\t",
			"\tint rank(int u) const noexcept {",
			"\t\tassert(0 <= u && u < size());",
			"\t\treturn rank_[u];",
			"\t}",
			"\t",
			"\tconst std::vector<int> & rank_list(int k) const noexcept {",
			"\t\tassert(0 <= k && k < scc_size());",
			"\t\treturn rank_list_[k];",
			"\t}",
			"\t",
			"\tGraph get_graph(const Graph & g) const {",
			"\t\tGraph res(scc_size());",
			"\t\tfor (int i = 0; i < scc_size(); ++i) {",
			"\t\t\tfor (int j : rank_list_[i]) for (int v : g[j]) if (rank(v) != i) res[i].emplace_back(rank(v));",
			"\t\t\tstd::sort(begin(res[i]), end(res[i]));",
			"\t\t\tres[i].erase(unique(begin(res[i]), end(res[i])), end(res[i]));",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};",
		],
		"description": ""
	},
	
	/* Mathematics */
	"ModInt": {
		"prefix": "ModInt",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/Mathematics/ModInt.hpp",
			" */",
			"template<int M>",
			"struct ModInt {",
			"\tstatic_assert(M > 0);",
			"\t",
			"\tusing value_type = int;",
			"\tusing calc_type = std::int_fast64_t;",
			"\t",
			"private:",
			"\tvalue_type val_;",
			"\t",
			"public:",
			"\tconstexpr ModInt(calc_type val = 0) : val_(val % M + (val >= 0 ? 0 : M)) {}",
			"\tconstexpr value_type val() const noexcept { return val_; }",
			"\tconstexpr static decltype(M) mod() noexcept { return M; }",
			"\t",
			"\texplicit constexpr operator bool() const noexcept { return val_; }",
			"\tconstexpr bool operator !() const noexcept { return !static_cast<bool>(*this); }",
			"\tconstexpr ModInt operator +() const noexcept { return *this; }",
			"\tconstexpr ModInt operator -() const noexcept { return ModInt(val_ == 0 ? 0 : M - val_); }",
			"\tconstexpr ModInt operator ++(int) noexcept { ModInt res = *this; ++*this; return res; }",
			"\tconstexpr ModInt operator --(int) noexcept { ModInt res = *this; --*this; return res; }",
			"\tconstexpr ModInt & operator ++() noexcept { val_ = val_ + 1 == M ? 0 : val_ + 1; return *this; }",
			"\tconstexpr ModInt & operator --() noexcept { val_ = val_ == 0 ? M - 1 : val_ - 1; return *this; }",
			"\tconstexpr ModInt & operator +=(const ModInt & rhs) noexcept { val_ += val_ < M - rhs.val_ ? rhs.val_ : rhs.val_ - M; return *this; }",
			"\tconstexpr ModInt & operator -=(const ModInt & rhs) noexcept { val_ += val_ >= rhs.val_ ? -rhs.val_ : M - rhs.val_; return *this; }",
			"\tconstexpr ModInt & operator *=(const ModInt & rhs) noexcept { val_ = static_cast<calc_type>(val_) * rhs.val_ % M; return *this; }",
			"\tconstexpr ModInt & operator /=(const ModInt & rhs) noexcept { return *this *= rhs.inv(); }",
			"\tfriend constexpr ModInt operator +(const ModInt & lhs, const ModInt & rhs) noexcept { return ModInt(lhs) += rhs; }",
			"\tfriend constexpr ModInt operator -(const ModInt & lhs, const ModInt & rhs) noexcept { return ModInt(lhs) -= rhs; }",
			"\tfriend constexpr ModInt operator *(const ModInt & lhs, const ModInt & rhs) noexcept { return ModInt(lhs) *= rhs; }",
			"\tfriend constexpr ModInt operator /(const ModInt & lhs, const ModInt & rhs) noexcept { return ModInt(lhs) /= rhs; }",
			"\tfriend constexpr bool operator ==(const ModInt & lhs, const ModInt & rhs) noexcept { return lhs.val_ == rhs.val_; }",
			"\tfriend constexpr bool operator !=(const ModInt & lhs, const ModInt & rhs) noexcept { return !(lhs == rhs); }",
			"\tfriend std::ostream & operator <<(std::ostream & os, const ModInt & rhs) { return os << rhs.val_; }",
			"\tfriend std::istream & operator >>(std::istream & is, ModInt & rhs) { calc_type x; is >> x; rhs = ModInt(x); return is; }",
			"\t",
			"\tconstexpr ModInt pow(calc_type n) const noexcept {",
			"\t\tModInt res = 1, x = val_;",
			"\t\tif (n < 0) { x = x.inv(); n = -n; }",
			"\t\twhile (n) { if (n & 1) res *= x; x *= x; n >>= 1; }",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tconstexpr ModInt inv() const noexcept {",
			"\t\tvalue_type a = val_, a1 = 1, b = M, b1 = 0;",
			"\t\twhile (b > 0) {",
			"\t\t\tconst value_type q = a / b;",
			"\t\t\tvalue_type tmp = a - q * b; a = b; b = tmp;",
			"\t\t\ttmp = a1 - q * b1; a1 = b1; b1 = tmp;",
			"\t\t}",
			"\t\tassert(a == 1);",
			"\t\tif (a1 < 0) a1 += M;",
			"\t\treturn a1;",
			"\t}",
			"};",
			"using mint = ModInt<MOD>;",
		],
		"description": ""
	},
	
	"RuntimeModInt": {
		"prefix": "RuntimeModInt",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/Mathematics/RuntimeModInt.hpp",
			" */",
			"template<int ID>",
			"struct RuntimeModInt {",
			"\tusing value_type = int;",
			"\tusing calc_type = std::int_fast64_t;",
			"\t",
			"private:",
			"\tvalue_type val_;",
			"\tstatic int & mod_() noexcept { static int M = 2; return M; }",
			"\t",
			"public:",
			"\tRuntimeModInt(calc_type val = 0) : val_(val % mod() + (val >= 0 ? 0 : mod())) {}",
			"\tconst value_type val() const noexcept { return val_; }",
			"\tstatic void set_mod(int M) noexcept { assert(M > 0); mod_() = M; }",
			"\tstatic int mod() noexcept { return mod_(); }",
			"\t",
			"\texplicit operator bool() const noexcept { return val_; }",
			"\tbool operator !() const noexcept { return !static_cast<bool>(*this); }",
			"\tRuntimeModInt operator +() const noexcept { return *this; }",
			"\tRuntimeModInt operator -() const noexcept { return RuntimeModInt(val_ == 0 ? 0 : mod() - val_); }",
			"\tRuntimeModInt operator ++(int) noexcept { RuntimeModInt res = *this; ++*this; return res; }",
			"\tRuntimeModInt operator --(int) noexcept { RuntimeModInt res = *this; --*this; return res; }",
			"\tRuntimeModInt & operator ++() noexcept { val_ = val_ + 1 == mod() ? 0 : val_ + 1; return *this; }",
			"\tRuntimeModInt & operator --() noexcept { val_ = val_ == 0 ? mod() - 1 : val_ - 1; return *this; }",
			"\tRuntimeModInt & operator +=(const RuntimeModInt & rhs) noexcept { val_ += val_ < mod() - rhs.val_ ? rhs.val_ : rhs.val_ - mod(); return *this; }",
			"\tRuntimeModInt & operator -=(const RuntimeModInt & rhs) noexcept { val_ += val_ >= rhs.val_ ? -rhs.val_ : mod() - rhs.val_; return *this; }",
			"\tRuntimeModInt & operator *=(const RuntimeModInt & rhs) noexcept { val_ = static_cast<calc_type>(val_) * rhs.val_ % mod(); return *this; }",
			"\tRuntimeModInt & operator /=(const RuntimeModInt & rhs) noexcept { return *this *= rhs.inv(); }",
			"\tfriend RuntimeModInt operator +(const RuntimeModInt & lhs, const RuntimeModInt & rhs) noexcept { return RuntimeModInt(lhs) += rhs; }",
			"\tfriend RuntimeModInt operator -(const RuntimeModInt & lhs, const RuntimeModInt & rhs) noexcept { return RuntimeModInt(lhs) -= rhs; }",
			"\tfriend RuntimeModInt operator *(const RuntimeModInt & lhs, const RuntimeModInt & rhs) noexcept { return RuntimeModInt(lhs) *= rhs; }",
			"\tfriend RuntimeModInt operator /(const RuntimeModInt & lhs, const RuntimeModInt & rhs) noexcept { return RuntimeModInt(lhs) /= rhs; }",
			"\tfriend bool operator ==(const RuntimeModInt & lhs, const RuntimeModInt & rhs) noexcept { return lhs.val_ == rhs.val_; }",
			"\tfriend bool operator !=(const RuntimeModInt & lhs, const RuntimeModInt & rhs) noexcept { return !(lhs == rhs); }",
			"\tfriend std::ostream & operator <<(std::ostream & os, const RuntimeModInt & rhs) { return os << rhs.val_; }",
			"\tfriend std::istream & operator >>(std::istream & is, RuntimeModInt & rhs) { calc_type x; is >> x; rhs = RuntimeModInt(x); return is; }",
			"\t",
			"\tRuntimeModInt pow(calc_type n) const noexcept {",
			"\t\tRuntimeModInt res = 1, x = val_;",
			"\t\tif (n < 0) { x = x.inv(); n = -n; }",
			"\t\twhile (n) { if (n & 1) res *= x; x *= x; n >>= 1; }",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tRuntimeModInt inv() const noexcept {",
			"\t\tvalue_type a = val_, a1 = 1, b = mod(), b1 = 0;",
			"\t\twhile (b > 0) {",
			"\t\t\tconst value_type q = a / b;",
			"\t\t\tvalue_type tmp = a - q * b; a = b; b = tmp;",
			"\t\t\ttmp = a1 - q * b1; a1 = b1; b1 = tmp;",
			"\t\t}",
			"\t\tassert(a == 1);",
			"\t\tif (a1 < 0) a1 += mod();",
			"\t\treturn a1;",
			"\t}",
			"};",
			"using mint = RuntimeModInt<-1>;",
		],
		"description": ""
	},
	
	"Combination": {
		"prefix": "Combination",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/Mathematics/Combination.hpp",
			" */",
			"template<typename T>",
			"struct Combination {",
			"\tusing size_type = std::size_t;",
			"\t",
			"private:",
			"\tstd::vector<T> fact_, finv_, inv_;",
			"\tstatic constexpr size_type MAX_LIMIT = 50000000;",
			"\t",
			"public:",
			"\texplicit Combination(size_type sz = 1) : fact_(1, 1), finv_(1, 1), inv_(1, 1) { build(sz); }",
			"\t",
			"\tT fact(size_type k) { if (k >= T::mod()) return 0; build(k); return fact_[k]; }",
			"\tT finv(size_type k) { assert(k < T::mod()); build(k); return finv_[k]; }",
			"\tT inv(size_type k) { assert(k > 0 && k < T::mod()); build(k); return inv_[k]; }",
			"\tT operator ()(int n, int r) { return c(n, r); }",
			"\tT c(int n, int r) {",
			"\t\tif (r < 0 || n < r) return 0;",
			"\t\treturn fact(n) * finv(r) * finv(n - r);",
			"\t}",
			"\t",
			"private:",
			"\tvoid build(size_type k) {",
			"\t\tif (fact_.size() > k) return;",
			"\t\tassert(k < MAX_LIMIT);",
			"\t\tsize_type sz = std::min({MAX_LIMIT, static_cast<size_type>(T::mod()), std::max(fact_.size() * 2, k + 1)});",
			"\t\tsize_type presz = fact_.size();",
			"\t\tfact_.resize(sz);",
			"\t\tfinv_.resize(sz);",
			"\t\tinv_.resize(sz);",
			"\t\tfor (size_type i = presz; i < sz; ++i) fact_[i] = fact_[i - 1] * i;",
			"\t\tfinv_[sz - 1] = fact_[sz - 1].inv();",
			"\t\tfor (size_type i = sz - 1; i > presz; --i) {",
			"\t\t\tfinv_[i - 1] = finv_[i] * i;",
			"\t\t\tinv_[i] = fact_[i - 1] * finv_[i];",
			"\t\t}",
			"\t\tinv_[presz] = fact_[presz - 1] * finv_[presz];",
			"\t}",
			"};",
			"using Comb = Combination<mint>;",
			"Comb comb;",
		],
		"description": ""
	},
	
	"euclid": {
		"prefix": "euclid",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/Mathematics/euclid.hpp",
			" */",
			"namespace tk {",
			"template<typename T>",
			"constexpr T gcd(T a, T b) noexcept {",
			"\tstatic_assert(std::is_integral<T>::value);",
			"\tassert(a >= 0);",
			"\tassert(b >= 0);",
			"\twhile (b != 0) {",
			"\t\tconst T t = a % b;",
			"\t\ta = b; b = t;",
			"\t}",
			"\treturn a;",
			"}",
			"",
			"template<typename T>",
			"constexpr T lcm(T a, T b) noexcept {",
			"\tstatic_assert(std::is_integral<T>::value);",
			"\tassert(a >= 0);",
			"\tassert(b >= 0);",
			"\tif (a == 0 || b == 0) return 0;",
			"\treturn a / gcd(a, b) * b;",
			"}",
			"",
			"template<typename T>",
			"constexpr std::tuple<T, T, T> ext_gcd(T a, T b) noexcept {",
			"\tstatic_assert(std::is_integral<T>::value);",
			"\tstatic_assert(std::is_signed<T>::value);",
			"\tassert(a != 0);",
			"\tassert(b != 0);",
			"\tT a1 = (a > 0) * 2 - 1, a2 = 0, b1 = 0, b2 = (b > 0) * 2 - 1;",
			"\ta = std::abs(a);",
			"\tb = std::abs(b);",
			"\twhile (b > 0) {",
			"\t\tconst T q = a / b;",
			"\t\tT tmp = a - q * b; a = b; b = tmp;",
			"\t\ttmp = a1 - q * b1; a1 = b1; b1 = tmp;",
			"\t\ttmp = a2 - q * b2; a2 = b2; b2 = tmp;",
			"\t}",
			"\treturn {a, a1, a2};",
			"}",
			"} // namespace tk",
		],
		"description": ""
	},
	
	"mod_pow_inv": {
		"prefix": "mod_pow_inv",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/Mathematics/mod_pow_inv.hpp",
			" */",
			"namespace tk {",
			"template<typename T>",
			"constexpr T mod_pow(T x, T n, T m) noexcept {",
			"\tstatic_assert(std::is_integral<T>::value);",
			"\tassert(m > 0);",
			"\tassert(n >= 0);",
			"\tx = x % m + (x >= 0 ? 0 : m);",
			"\tT res = 1 % m;",
			"\twhile (n > 0) {",
			"\t\tif (n & 1) res = res * x % m;",
			"\t\tx = x * x % m;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"template<typename T>",
			"constexpr T mod_inv(T x, T m) noexcept {",
			"\tstatic_assert(std::is_integral<T>::value);",
			"\tstatic_assert(std::is_signed<T>::value);",
			"\tassert(m > 0);",
			"\tx = x % m + (x >= 0 ? 0 : m);",
			"\tT x1 = 1, y = m, y1 = 0;",
			"\twhile (y > 0) {",
			"\t\tconst T q = x / y;",
			"\t\tT tmp = x - q * y; x = y; y = tmp;",
			"\t\ttmp = x1 - q * y1; x1 = y1; y1 = tmp;",
			"\t}",
			"\tassert(x == 1);",
			"\tif (x1 == m) x1 = 0;",
			"\tif (x1 < 0) x1 += m;",
			"\treturn x1;",
			"}",
			"} // namespace tk",
		],
		"description": ""
	},
	
	"chinese_remainder": {
		"prefix": "chinese_remainder",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/Mathematics/euclid.hpp",
			" */",
			"namespace tk {",
			"template<typename T>",
			"constexpr std::tuple<T, T, T> ext_gcd(T a, T b) noexcept {",
			"\tstatic_assert(std::is_integral<T>::value);",
			"\tstatic_assert(std::is_signed<T>::value);",
			"\tassert(a != 0);",
			"\tassert(b != 0);",
			"\tT a1 = (a > 0) * 2 - 1, a2 = 0, b1 = 0, b2 = (b > 0) * 2 - 1;",
			"\ta = std::abs(a);",
			"\tb = std::abs(b);",
			"\twhile (b > 0) {",
			"\t\tconst T q = a / b;",
			"\t\tT tmp = a - q * b; a = b; b = tmp;",
			"\t\ttmp = a1 - q * b1; a1 = b1; b1 = tmp;",
			"\t\ttmp = a2 - q * b2; a2 = b2; b2 = tmp;",
			"\t}",
			"\treturn {a, a1, a2};",
			"}",
			"} // namespace tk",
			"",
			"/**",
			" * @brief https://tkmst201.github.io/Library/Mathematics/chinese_remainder.hpp",
			" */",
			"namespace tk {",
			"template<typename T>",
			"constexpr std::pair<T, T> chinese_remainder(T b1, T m1, T b2, T m2) noexcept {",
			"\tstatic_assert(std::is_integral<T>::value);",
			"\tassert(m1 > 0);",
			"\tassert(m2 > 0);",
			"\tif (m1 < m2) { std::swap(b1, b2); std::swap(m1, m2); }",
			"\tb1 = b1 % m1 + (b1 >= 0 ? 0 : m1);",
			"\tb2 = b2 % m2 + (b2 >= 0 ? 0 : m2);",
			"\tauto [g, x, _] = ext_gcd(m1, m2);",
			"\tif ((b2 - b1) % g != 0) return {0, 0};",
			"\tconst T pm2 = m2 / g;",
			"\tif (x < 0) x += pm2;",
			"\tconst T t = ((b2 - b1) / g % pm2 + pm2) % pm2 * x % pm2;",
			"\treturn {b1 + t * m1, m1 * pm2};",
			"}",
			"} // namespace tk",
		],
		"description": ""
	},
	
	"Matrix": {
		"prefix": "Matrix",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/Mathematics/Matrix.hpp",
			" */",
			"template<typename T>",
			"struct Matrix {",
			"\tusing value_type = T;",
			"\tusing size_type = std::size_t;",
			"\tusing uint32 = std::uint32_t;",
			"\t",
			"private:",
			"\tsize_type h = 0, w = 0;",
			"\tstd::vector<std::vector<value_type>> val;",
			"\tconstexpr static value_type eps = std::is_floating_point<value_type>::value ? 1e-8 : 0;",
			"\t",
			"public:",
			"\tMatrix() = default;",
			"\t",
			"\tMatrix(size_type h, size_type w, const value_type & x = 0)",
			"\t\t: h(h), w(w), val(h, std::vector<value_type>(w, x)) {}",
			"\t",
			"\texplicit Matrix(const std::vector<std::vector<value_type>> & val)",
			"\t\t: h(val.size()), w(val.empty() ? 0 : val[0].size()), val(val) {",
			"\t\tfor (size_type i = 1; i < h; ++i) assert(val[i].size() == w);",
			"\t}",
			"\t",
			"\texplicit Matrix(std::initializer_list<std::vector<value_type>> init) : val(init.begin(), init.end()) {",
			"\t\th = val.size();",
			"\t\tw = val.empty() ? 0 : val[0].size();",
			"\t\tfor (size_type i = 1; i < h; ++i) assert(val[i].size() == w);",
			"\t}",
			"\t",
			"\tstatic Matrix identity(size_type n) {",
			"\t\tMatrix res(n, n);",
			"\t\tfor (size_type i = 0; i < n; ++i) res(i, i) = 1;",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tMatrix operator +() const noexcept {",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tMatrix operator -() const {",
			"\t\treturn Matrix(h, w, 0) -= *this;",
			"\t}",
			"\t",
			"\tMatrix & operator +=(const Matrix & rhs) noexcept {",
			"\t\tassert(match_type(rhs));",
			"\t\tfor (size_type i = 0; i < h; ++i) for (size_type j = 0; j < w; ++j) val[i][j] += rhs.val[i][j];",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tMatrix & operator -=(const Matrix & rhs) noexcept {",
			"\t\tassert(match_type(rhs));",
			"\t\tfor (size_type i = 0; i < h; ++i) for(size_type j = 0; j < w; ++j) val[i][j] -= rhs.val[i][j];",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tMatrix & operator *=(const Matrix & rhs) {",
			"\t\tassert(w == rhs.h);",
			"\t\tMatrix mat(h, rhs.w);",
			"\t\tfor (size_type i = 0; i < h; ++i) for (size_type j = 0; j < rhs.w; ++j) for (size_type k = 0; k < w; ++k)",
			"\t\t\tmat.val[i][j] += val[i][k] * rhs.val[k][j];",
			"\t\th = mat.h;",
			"\t\tw = mat.w;",
			"\t\tval = std::move(mat.val);",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tMatrix & operator /=(const Matrix & rhs) {",
			"\t\tassert(rhs.is_square());",
			"\t\tassert(!rhs.empty());",
			"\t\tassert(w == rhs.h);",
			"\t\tconst Matrix mat = rhs.inv();",
			"\t\tassert(!mat.empty());",
			"\t\t*this *= mat;",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tfriend Matrix operator +(const Matrix & lhs, const Matrix & rhs) {",
			"\t\treturn Matrix(lhs) += rhs;",
			"\t}",
			"\t",
			"\tfriend Matrix operator -(const Matrix & lhs, const Matrix & rhs) {",
			"\t\treturn Matrix(lhs) -= rhs;",
			"\t}",
			"\t",
			"\tfriend Matrix operator *(const Matrix & lhs, const Matrix & rhs) {",
			"\t\treturn Matrix(lhs) *= rhs;",
			"\t}",
			"\t",
			"\tfriend Matrix operator /(const Matrix & lhs, const Matrix & rhs) {",
			"\t\treturn Matrix(lhs) /= rhs;",
			"\t}",
			"\t",
			"\tfriend Matrix operator *(const value_type & lhs, const Matrix & rhs) {",
			"\t\tMatrix res(rhs.val);",
			"\t\tfor (size_type i = 0; i < res.h; ++i) for (size_type j = 0; j < res.w; ++j) res.val[i][j] = lhs * res.val[i][j];",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tfriend Matrix operator *(const Matrix & lhs, const value_type & rhs) {",
			"\t\tMatrix res(lhs.val);",
			"\t\tfor (size_type i = 0; i < res.h; ++i) for (size_type j = 0; j < res.w; ++j) res.val[i][j] *= rhs;",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tfriend Matrix operator /(const Matrix & lhs, const value_type & rhs) {",
			"\t\tif constexpr (std::is_floating_point<value_type>::value) assert(std::abs(rhs) >= eps);",
			"\t\telse assert(rhs != 0);",
			"\t\tMatrix res(lhs.val);",
			"\t\tfor (size_type i = 0; i < res.h; ++i) for (size_type j = 0; j < res.w; ++j) res.val[i][j] /= rhs;",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tfriend bool operator ==(const Matrix & lhs, const Matrix & rhs) noexcept {",
			"\t\tif (!lhs.match_type(rhs)) return false;",
			"\t\tif constexpr (!std::is_floating_point<value_type>::value) return lhs.val == rhs.val;",
			"\t\telse {",
			"\t\t\tfor (size_type i = 0; i < lhs.h; ++i) for (size_type j = 0; j < lhs.w; ++j) {",
			"\t\t\t\tif (std::abs(lhs.val[i][j] - rhs.val[i][j]) >= eps) return false;",
			"\t\t\t}",
			"\t\t\treturn true;",
			"\t\t}",
			"\t}",
			"\t",
			"\tfriend bool operator !=(const Matrix & lhs, const Matrix & rhs) noexcept {",
			"\t\treturn !(lhs == rhs);",
			"\t}",
			"\t",
			"\tstd::vector<value_type> & operator [](size_type i) noexcept {",
			"\t\treturn val[i];",
			"\t}",
			"\t",
			"\tconst std::vector<value_type> & operator [](size_type i) const noexcept {",
			"\t\treturn val[i];",
			"\t};",
			"\t",
			"\tvalue_type & at(size_type i, size_type j) noexcept {",
			"\t\tassert(i < h);",
			"\t\tassert(j < w);",
			"\t\treturn val[i][j];",
			"\t}",
			"\t",
			"\tconst value_type & at(size_type i, size_type j) const noexcept {",
			"\t\tassert(i < h);",
			"\t\tassert(j < w);",
			"\t\treturn val[i][j];",
			"\t}",
			"\t",
			"\tvalue_type & operator ()(size_type i, size_type j) noexcept {",
			"\t\tassert(i < h);",
			"\t\tassert(j < w);",
			"\t\treturn val[i][j];",
			"\t};",
			"\t",
			"\tconst value_type & operator ()(size_type i, size_type j) const noexcept {",
			"\t\tassert(i < h);",
			"\t\tassert(j < w);",
			"\t\treturn val[i][j];",
			"\t}",
			"\t",
			"\tbool empty() const noexcept {",
			"\t\treturn h == 0 && w == 0;",
			"\t}",
			"\t",
			"\tstd::pair<size_type, size_type> type() const noexcept {",
			"\t\treturn {h, w};",
			"\t}",
			"\t",
			"\tbool match_type(const Matrix & A) const noexcept {",
			"\t\treturn h == A.h && w == A.w;",
			"\t}",
			"\t",
			"\tbool is_square() const noexcept {",
			"\t\treturn h == w;",
			"\t}",
			"\t",
			"\tconst std::vector<std::vector<value_type>> & get() const noexcept {",
			"\t\treturn val;",
			"\t}",
			"\t",
			"\tMatrix pow(long long n) const {",
			"\t\tassert(h == w);",
			"\t\tassert(n >= 0);",
			"\t\tMatrix res = identity(h), x(*this);",
			"\t\twhile (n > 0) { if (n & 1) res *= x; x *= x; n >>= 1; }",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tMatrix trans() const {",
			"\t\tMatrix res(w, h);",
			"\t\tfor (size_type i = 0; i < h; ++i) for (size_type j = 0; j < w; ++j) res.val[j][i] = val[i][j];",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tMatrix vstack(const Matrix & A) const {",
			"\t\tassert(w == A.w);",
			"\t\tMatrix res(h + A.h, w);",
			"\t\tstd::copy(val.begin(), val.end(), res.val.begin());",
			"\t\tstd::copy(A.val.begin(), A.val.end(), res.val.begin() + h);",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tMatrix hstack(const Matrix & A) const {",
			"\t\tassert(h == A.h);",
			"\t\tMatrix res(h, w + A.w);",
			"\t\tfor (int i = 0; i < h; ++i) {",
			"\t\t\tstd::copy(val[i].begin(), val[i].end(), res.val[i].begin());",
			"\t\t\tstd::copy(A.val[i].begin(), A.val[i].end(), res.val[i].begin() + w);",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tMatrix submat(size_type i1, size_type i2, size_type j1, size_type j2) const {",
			"\t\tassert(i1 < i2 && i2 <= h);",
			"\t\tassert(j1 < j2 && j2 <= w);",
			"\t\tMatrix res(i2 - i1, j2 - j1);",
			"\t\tfor (size_type i = 0; i < i2 - i1; ++i) std::copy(val[i + i1].begin() + j1, val[i + i1].begin() + j2, res.val[i].begin());",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tMatrix inv() const {",
			"\t\tassert(is_square());",
			"\t\tMatrix aug_mat = this->hstack(identity(h));",
			"\t\tif (aug_mat.gauss_jordan(h).first != h) return Matrix();",
			"\t\treturn aug_mat.submat(0, h, h, 2 * h);",
			"\t}",
			"\t",
			"\tvalue_type det() const {",
			"\t\tassert(is_square());",
			"\t\treturn Matrix(*this).gauss_jordan(w).second;",
			"\t}",
			"\t",
			"\tstd::pair<uint32, value_type> gauss_jordan(uint32 col) noexcept {",
			"\t\tassert(col <= w);",
			"\t\tuint32 rank = 0;",
			"\t\tvalue_type det = empty() || !is_square() ? 0 : 1;",
			"\t\tbool rflag = false;",
			"\t\tfor (uint32 k = 0; k < col; ++k) {",
			"\t\t\tint pivot = -1;",
			"\t\t\tif constexpr (std::is_floating_point<value_type>::value) {",
			"\t\t\t\tvalue_type mx = eps;",
			"\t\t\t\tfor (uint32 i = rank; i < h; ++i) {",
			"\t\t\t\t\tconst value_type cur = std::abs(val[i][k]);",
			"\t\t\t\t\tif (mx < cur) mx = cur, pivot = i;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tfor (uint32 i = rank; i < h; ++i) if (val[i][k] != 0) { pivot = i; break; }",
			"\t\t\t}",
			"\t\t\tif (pivot == -1) continue;",
			"\t\t\tif (static_cast<uint32>(pivot) != rank) {",
			"\t\t\t\trflag ^= true;",
			"\t\t\t\tstd::swap(val[pivot], val[rank]);",
			"\t\t\t}",
			"\t\t\tdet *= val[rank][k];",
			"\t\t\tconst value_type div = static_cast<value_type>(1) / val[rank][k];",
			"\t\t\tval[rank][k] = 1;",
			"\t\t\tfor (uint32 j = k + 1; j < w; ++j) val[rank][j] *= div;",
			"\t\t\tfor (uint32 i = 0; i < rank; ++i) {",
			"\t\t\t\tfor (uint32 j = k + 1; j < w; ++j) val[i][j] -= val[rank][j] * val[i][k];",
			"\t\t\t\tval[i][k] = 0;",
			"\t\t\t}",
			"\t\t\tfor (uint32 i = std::max<uint32>(rank + 1, pivot); i < h; ++i) {",
			"\t\t\t\tfor (uint32 j = k + 1; j < w; ++j) val[i][j] -= val[rank][j] * val[i][k];",
			"\t\t\t\tval[i][k] = 0;",
			"\t\t\t}",
			"\t\t\t++rank;",
			"\t\t}",
			"\t\tif (rank != h) det = 0;",
			"\t\tif (rflag) det = -det;",
			"\t\treturn {rank, det};",
			"\t}",
			"\t",
			"\tfriend std::ostream & operator <<(std::ostream & os, const Matrix & rhs) {",
			"\t\tos << \"type = (\" << rhs.h << \",\" << rhs.w << \") [\\n\";",
			"\t\tfor (size_type i = 0; i < rhs.h; ++i) {",
			"\t\t\tos << ' ';",
			"\t\t\tfor (size_type j = 0; j < rhs.w; ++j) os << rhs.val[i][j] << \" \\n\"[j + 1 == rhs.w];",
			"\t\t}",
			"\t\treturn os << \"]\";",
			"\t}",
			"};",
		],
		"description": ""
	},
	
	"Polynomial": {
		"prefix": "Polynomial",
		"body": [
			"namespace tk {",
			"template<typename T>",
			"std::vector<T> linear_prod(const std::vector<T> & poly, T d) {",
			"\tassert(!poly.empty());",
			"\tusing size_type = std::size_t;",
			"\tstd::vector<T> res;",
			"\tres.reserve(poly.size() + 1);",
			"\tres.emplace_back(poly[0] * (static_cast<mint>(0) - d));",
			"\tfor (size_type i = 1; i < poly.size(); ++i)",
			"\t\tres.emplace_back(poly[i - 1] + poly[i] * (static_cast<mint>(0) - d));",
			"\tres.emplace_back(poly.back());",
			"\treturn res;",
			"}",
			"",
			"template<typename T>",
			"std::vector<T> linear_div(const std::vector<T> & poly, T d) {",
			"\tassert(poly.size() >= 2);",
			"\tusing size_type = std::size_t;",
			"\tstd::vector<T> res(poly.size() - 1);",
			"\tT r = 0;",
			"\tfor (size_type i = poly.size() - 1; i > 0; --i) {",
			"\t\tres[i - 1] = r + poly[i];",
			"\t\tr = res[i - 1] * d;",
			"\t}",
			"\tr += poly[0];",
			"\tassert(r == 0);",
			"\treturn res;",
			"}",
			"} // namespace tk\n",
		],
		"description": [
			"多項式と 1 次式の乗除(削除予定)",
			"https://tkmst201.github.io/Library/Mathematics/Polynomial.hpp",
			"2020/11/02"
		]
	},
	
	/* Convolution */
	"FastFourierTransform": {
		"prefix": "FastFourierTransform",
		"body": [
			"/**",
			" * @brief https://tkmst201.github.io/Library/Convolution/FastFourierTransform.hpp",
			" */",
			"struct FastFourierTransform {",
			"\tusing value_type = double;",
			"\tusing complex_type = std::complex<value_type>;",
			"\t",
			"private:",
			"\tusing uint32 = std::uint32_t;",
			"\tconstexpr static value_type pi = 3.1415926535897932384626433832795028841972;",
			"\tconstexpr static complex_type ie{0, 1};",
			"\t",
			"\tuint32 mlog_n;",
			"\tstd::vector<complex_type> zeta;",
			"\t",
			"public:",
			"\texplicit FastFourierTransform(uint32 max_n) : mlog_n(calc_l2(max_n)), zeta(zeta_(mlog_n)) {}",
			"\t",
			"\ttemplate<typename T>",
			"\tstd::vector<value_type> operator ()(const std::vector<T> & a, const std::vector<T> & b) const {",
			"\t\tif (a.empty() || b.empty()) return {};",
			"\t\tif (a.size() == 1 && b.size() == 1) return {static_cast<value_type>(a.front()) * b.front()};",
			"\t\tassert((a.size() + b.size() - 1) <= (1u << mlog_n));",
			"\t\treturn multiply_sub(a, b, zeta, mlog_n);",
			"\t}",
			"\t",
			"\ttemplate<typename T>",
			"\tstatic std::vector<value_type> multiply(const std::vector<T> & a, const std::vector<T> & b) {",
			"\t\tif (a.empty() || b.empty()) return {};",
			"\t\tif (a.size() == 1 && b.size() == 1) return {static_cast<value_type>(a.front()) * b.front()};",
			"\t\tconst uint32 log_n = calc_l2(a.size() + b.size() - 1);",
			"\t\tconst std::vector<complex_type> zeta = zeta_(log_n);",
			"\t\treturn multiply_sub(a, b, zeta, log_n);",
			"\t}",
			"\t",
			"private:",
			"\ttemplate<typename T>",
			"\tstatic std::vector<value_type> multiply_sub(const std::vector<T> & a, const std::vector<T> & b, const std::vector<complex_type> & zeta, uint32 log_z) {",
			"\t\tconst uint32 n_ = a.size() + b.size() - 1;",
			"\t\tconst uint32 log_n = calc_l2(n_), n = 1u << log_n, m = n >> 1;",
			"\t\tstd::vector<complex_type> h(n);",
			"\t\tfor (uint32 i = 0; i < a.size(); ++i) h[i].real(a[i]);",
			"\t\tfor (uint32 i = 0; i < b.size(); ++i) h[i].imag(b[i]);",
			"\t\tfft(h, log_n, zeta, log_z);",
			"\t\t",
			"\t\tstd::vector<complex_type> p(m);",
			"\t\t{",
			"\t\t\tconst value_type cf = h[0].real() * h[0].imag();",
			"\t\t\tconst value_type cb = h[m].real() * h[m].imag();",
			"\t\t\tp[0] = complex_type(cf + cb, -(cf - cb)) / 2.0;",
			"\t\t}",
			"\t\tfor (uint32 i = 1; i <= (m >> 1); ++i) {",
			"\t\t\tconst complex_type cf = -(h[i] + std::conj(h[n - i])) * (h[i] - std::conj(h[n - i])) * ie;",
			"\t\t\tconst complex_type cb = -(h[m - i] + std::conj(h[m + i])) * (h[m - i] - std::conj(h[m + i])) * ie;",
			"\t\t\tp[i] = std::conj((cf + std::conj(cb) + (cf - std::conj(cb)) * std::conj(zeta_f(log_n, i, zeta, log_z)) * ie)) / 8.0;",
			"\t\t\tif (i != m / 2) p[m - i] = std::conj((cb + std::conj(cf)) + (cb - std::conj(cf)) * std::conj(zeta_f(log_n, m - i, zeta, log_z)) * ie) / 8.0;",
			"\t\t}",
			"\t\tfft(p, log_n - 1, zeta, log_z);",
			"\t\t",
			"\t\tstd::vector<value_type> res;",
			"\t\tres.reserve(n_);",
			"\t\tfor (uint32 i = 0; i < m; ++i) {",
			"\t\t\tif ((i << 1) < n_) res.emplace_back(p[i].real() / static_cast<value_type>(m));",
			"\t\t\tif ((i << 1 | 1) < n_) res.emplace_back(-p[i].imag() / static_cast<value_type>(m));",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tstatic void fft(std::vector<complex_type> & a, uint32 log_n, const std::vector<complex_type> & zeta, uint32 log_z) {",
			"\t\tconst uint32 n = a.size(), m = n >> 1;",
			"\t\tbit_reverse(a);",
			"\t\tfor (uint32 w = 4, c = 2; w <= n; w <<= 2, c += 2) {",
			"\t\t\tconst uint32 s = w >> 2;",
			"\t\t\tfor (uint32 p = 0; p < n; p += w) {",
			"\t\t\t\tfor (uint32 i = 0; i < s; ++i) {",
			"\t\t\t\t\tconst uint32 pos = p + i;",
			"\t\t\t\t\tconst complex_type a0 = a[pos], a2 = a[pos + s] * zeta_f(c - 1, i, zeta, log_z);",
			"\t\t\t\t\tconst complex_type a1 = a[pos + (s << 1)] * zeta_f(c, i, zeta, log_z), a3 = a[pos + w - s] * zeta_f(c, 3 * i, zeta, log_z);",
			"\t\t\t\t\tconst complex_type lp = a0 + a2, rp = a1 + a3, ln = a0 - a2, rn = a1 - a3;",
			"\t\t\t\t\ta[pos] = lp + rp;",
			"\t\t\t\t\ta[pos + (s << 1)] = lp - rp;",
			"\t\t\t\t\ta[pos + s] = ln + rn * ie;",
			"\t\t\t\t\ta[pos + w - s] = ln - rn * ie;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tif (~log_n & 1) return;",
			"\t\tfor (uint32 i = 0; i < m; ++i) {",
			"\t\t\tconst complex_type x = a[i], y = a[i + m] * zeta_f(log_n, i, zeta, log_z);",
			"\t\t\ta[i] = x + y;",
			"\t\t\ta[i + m] = x - y;",
			"\t\t}",
			"\t}",
			"\t",
			"\tstatic uint32 calc_l2(uint32 n_) noexcept {",
			"\t\tuint32 log_n = 0;",
			"\t\tfor (uint32 n = 1; n < n_; n <<= 1) ++log_n;",
			"\t\treturn log_n;",
			"\t}",
			"\t",
			"\tstatic void bit_reverse(std::vector<complex_type> & a) noexcept {",
			"\t\tconst uint32 N = a.size();",
			"\t\tfor (uint32 i = 1, j = 0; i < N - 1; ++i) {",
			"\t\t\tfor (uint32 k = N >> 1; k > (j ^= k); k >>= 1);",
			"\t\t\tif (i < j) std::swap(a[i], a[j]);",
			"\t\t}",
			"\t}",
			"\t",
			"\tstatic std::vector<complex_type> zeta_(uint32 log_n) {",
			"\t\tif (log_n == 0) return {};",
			"\t\tstd::vector<complex_type> zeta;",
			"\t\tzeta.reserve(1 << (log_n - 1));",
			"\t\tzeta.emplace_back(1, 0);",
			"\t\tfor (uint32 i = 0; i < (log_n - 1); ++i) {",
			"\t\t\tconst complex_type t = std::polar<value_type>(1, 2.0 * pi / static_cast<value_type>(1 << (log_n - i)));",
			"\t\t\tzeta.emplace_back(t);",
			"\t\t\tfor (uint32 j = 1; j < (1u << i); ++j) zeta.emplace_back(zeta[j] * t);",
			"\t\t}",
			"\t\treturn zeta;",
			"\t}",
			"\t",
			"\tstatic complex_type zeta_f(uint32 d, uint32 p, const std::vector<complex_type> & zeta, uint32 log_z) noexcept {",
			"\t\tconst uint32 idx = p << (log_z - d);",
			"\t\treturn idx < zeta.size() ? zeta[idx] : -zeta[idx - zeta.size()];",
			"\t}",
			"};",
		],
		"description": ""
	},
	
	"NumberTheoreticTransform": {
		"prefix": "NumberTheoreticTransform",
		"body": [
			"mod_pow_inv",
			"",
			"/**",
			" * @brief https://tkmst201.github.io/Library/Convolution/NumberTheoreticTransform.hpp",
			" */",
			"template<int MOD, int PRIMITIVE_ROOT>",
			"struct NumberTheoreticTransform {",
			"\tstatic_assert(MOD > 0);",
			"\tstatic_assert(PRIMITIVE_ROOT > 0);",
			"\t",
			"private:",
			"\tusing uint32 = std::uint32_t;",
			"\tusing calc_type = long long;",
			"\t",
			"public:",
			"\ttemplate<typename T>",
			"\tstatic std::vector<T> multiply(const std::vector<T> & a, const std::vector<T> & b) {",
			"\t\tstatic_assert(std::is_integral<T>::value);",
			"\t\tif (a.empty() || b.empty()) return {};",
			"\t\tconst uint32 n_ = a.size() + b.size() - 1;",
			"\t\tuint32 n = 1;",
			"\t\twhile (n < n_) n <<= 1;",
			"\t\t{",
			"\t\t\tuint32 two_exp = 0;",
			"\t\t\tint tm = MOD - 1;",
			"\t\t\twhile (tm > 0 && (~tm & 1)) ++two_exp, tm >>= 1;",
			"\t\t\tassert((1u << two_exp) >= n);",
			"\t\t}",
			"\t\tstd::vector<T> c(n, 0);",
			"\t\tfor (uint32 i = 0; i < a.size(); ++i) c[i] = a[i] % MOD + (a[i] >= 0 ? 0 : MOD);",
			"\t\tntt(c);",
			"\t\tstd::vector<T> d(n, 0);",
			"\t\tfor (uint32 i = 0; i < b.size(); ++i) d[i] = b[i] % MOD + (b[i] >= 0 ? 0 : MOD);",
			"\t\tntt(d);",
			"\t\tconst int ninv = tk::mod_inv<int>(n, MOD);",
			"\t\tfor (uint32 i = 0; i < n; ++i) c[i] = static_cast<calc_type>(c[i]) * d[i] % MOD * ninv % MOD;",
			"\t\td.clear();",
			"\t\tntt(c, true);",
			"\t\tc.resize(a.size() + b.size() - 1);",
			"\t\treturn c;",
			"\t}",
			"\t",
			"private:",
			"\ttemplate<typename T>",
			"\tstatic void ntt(std::vector<T> & a, bool inv = false) {",
			"\t\tconst uint32 n = a.size();",
			"\t\tint nroot = tk::mod_pow<calc_type>(PRIMITIVE_ROOT, (MOD - 1) / n, MOD);",
			"\t\tif (inv) nroot = tk::mod_inv(nroot, MOD);",
			"\t\tfor (uint32 w = n; w > 1; w >>= 1) {",
			"\t\t\tconst uint32 m = w >> 1;",
			"\t\t\tstd::vector<int> omega(m, 0);",
			"\t\t\tomega[0] = 1;",
			"\t\t\tfor (uint32 i = 1; i < m; ++i) omega[i] = static_cast<calc_type>(omega[i - 1]) * nroot % MOD;",
			"\t\t\tconst int half = static_cast<calc_type>(omega.back()) * nroot % MOD;",
			"\t\t\tfor (uint32 p = 0; p < n; p += w) {",
			"\t\t\t\tfor (uint32 i = p; i < p + m; ++i) {",
			"\t\t\t\t\tconst calc_type x = a[i], y = a[i + m];",
			"\t\t\t\t\ta[i] = (x + y) % MOD;",
			"\t\t\t\t\ta[i + m] = (x + y * half % MOD) % MOD * omega[i - p] % MOD;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tnroot = static_cast<calc_type>(nroot) * nroot % MOD;",
			"\t\t}",
			"\t\tbit_reverse(a);",
			"\t}",
			"\t",
			"\ttemplate<typename T>",
			"\tstatic void bit_reverse(std::vector<T> & a) noexcept {",
			"\t\tconst uint32 n = a.size();",
			"\t\tfor (uint32 i = 1, j = 0; i < n - 1; ++i) {",
			"\t\t\tfor (uint32 k = n >> 1; k > (j ^= k); k >>= 1);",
			"\t\t\tif (i < j) std::swap(a[i], a[j]);",
			"\t\t}",
			"\t}",
			"};",
		],
		"description": ""
	},
	
	/* String */
	"RollingHash": {
		"prefix": "RollingHash",
		"body": [
			"struct RollingHash {",
			"public:",
			"\tusing size_type = std::size_t;",
			"\tusing string_type = std::string;",
			"\tusing uint64 = std::uint64_t;",
			"\t",
			"private:",
			"\tstatic constexpr uint64 mod = (1ull << 61) - 1;",
			"\tstatic constexpr uint64 mask31 = (1ull << 31) - 1;",
			"\tstatic constexpr uint64 mask30 = (1ull << 30) - 1;",
			"\tstatic constexpr uint64 mask61 = (1ull << 61) - 1;",
			"\t",
			"public:",
			"\tRollingHash(string_type s) {",
			"\t\tif (base().empty()) set_base();",
			"\t\tbuild(s);",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvoid build(string_type s) {",
			"\t\tn = s.size();",
			"\t\thashv.clear();",
			"\t\tbasep.clear();",
			"\t\tfor (size_type i = 0; i < base().size(); ++i) {",
			"\t\t\thashv.emplace_back();",
			"\t\t\tbasep.emplace_back();",
			"\t\t\thashv[i].emplace_back(0);",
			"\t\t\tbasep[i].emplace_back(1);",
			"\t\t\tfor (size_type j = 0; j < size(); ++j) {",
			"\t\t\t\tuint64 nh = mul(hashv[i].back(), base()[i]) + static_cast<uint64>(s[j]);",
			"\t\t\t\thashv[i].emplace_back(modulo(nh));",
			"\t\t\t\tbasep[i].emplace_back(modulo(mul(basep[i].back(), base()[i])));",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\tuint64 hash(size_type i, size_type l, size_type r) const {",
			"\t\tassert(i < base().size());",
			"\t\tassert(l < r);",
			"\t\tassert(r <= size());",
			"\t\treturn modulo((mod << 2) - mul(hashv[i][l], basep[i][r - l]) + hashv[i][r]);",
			"\t}",
			"\t",
			"\tstd::vector<uint64> hash(size_type l, size_type r) const {",
			"\t\tassert(l < r);",
			"\t\tassert(r <= size());",
			"\t\tstd::vector<uint64> res;",
			"\t\tfor (size_type i = 0; i < base().size(); ++i) res.emplace_back(hash(i, l, r));",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tbool match(size_type l1, size_type r1, size_type l2, size_type r2) const {",
			"\t\tassert(l1 < r1);",
			"\t\tassert(r1 <= size());",
			"\t\tassert(l2 < r2);",
			"\t\tassert(r2 <= size());",
			"\t\tfor (size_type i = 0; i < base().size(); ++i) if (hash(i, l1, r1) != hash(i, l2, r2)) return false;",
			"\t\treturn true;",
			"\t}",
			"\t",
			"private:",
			"\tsize_type n;",
			"\tstd::vector<std::vector<uint64>> basep;",
			"\tstd::vector<std::vector<uint64>> hashv; // [i][j] := hash(s[0..j-1]), use base[i]",
			"\t",
			"\tstatic std::vector<uint64> & base() {",
			"\t\tstatic std::vector<uint64> base_;",
			"\t\treturn base_;",
			"\t}",
			"\t",
			"\tstatic void set_base() {",
			"\t\tbase().emplace_back(100000001111);",
			"\t\t// base().emplace_back(100000011200);",
			"\t\t// base().emplace_back(100000011000);",
			"\t\t// base().emplace_back(100000014848);",
			"\t\t// base().emplace_back(100000015050);",
			"\t\t",
			"\t\tauto rnd = std::bind(std::uniform_int_distribution<uint64>(2, mod - 2), std::mt19937_64(std::random_device{}()));",
			"\t\tconstexpr size_type gen_cnt = 1;",
			"\t\tfor (size_type i = 0; i < gen_cnt; ++i) {",
			"\t\t\twhile (true) {",
			"\t\t\t\tuint64 k = rnd();",
			"\t\t\t\tif (gcd(k, mod - 1) != 1) continue;",
			"\t\t\t\tuint64 cur = mod_pow(base()[0], k);",
			"\t\t\t\tif (cur < 10000000000) continue;",
			"\t\t\t\tbase().emplace_back(cur);",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\t// x, y < mod => res < (mod << 2)",
			"\tstatic uint64 mul(uint64 x, uint64 y) {",
			"\t\tconst uint64 xu = x >> 31, xd = x & mask31;",
			"\t\tconst uint64 yu = y >> 31, yd = y & mask31;",
			"\t\tconst uint64 t = xu * yd + yu * xd;",
			"\t\tuint64 res = (xu * yu) << 1;",
			"\t\tres += (t >> 30) + ((t & mask30) << 31);",
			"\t\tres += xd * yd;",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tstatic uint64 modulo(uint64 x) {",
			"\t\tconst uint64 sum = (x >> 61) + (x & mask61);",
			"\t\treturn sum < mod ? sum : sum - mod;",
			"\t}",
			"\t",
			"\tstatic uint64 mod_pow(uint64 x, uint64 n) {",
			"\t\tif (n == 0) return 1;",
			"\t\tuint64 res = mod_pow(modulo(mul(x, x)), n >> 1);",
			"\t\tif (n & 1) res = modulo(mul(res, x));",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tstatic uint64 gcd(uint64 x, uint64 y) {",
			"\t\twhile (y > 0) {",
			"\t\t\tuint64 t = y;",
			"\t\t\ty = x % y;",
			"\t\t\tx = t;",
			"\t\t}",
			"\t\treturn x;",
			"\t}",
			"};\n",
		],
		"description": [
			"ローリングハッシュ",
			"https://tkmst201.github.io/Library/String/RollingHash.hpp",
			"2020/08/22"
		]
	},
	
	"SuffixArray": {
		"prefix": "SuffixArray",
		"body": [
			"struct SuffixArray {",
			"\tusing size_type = std::size_t;",
			"\tusing string_type = std::string;",
			"\t",
			"\tSuffixArray(string_type s) {",
			"\t\tbuild(s);",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn s.size();",
			"\t}",
			"\t",
			"\tconst size_type & operator[](size_type i) const noexcept {",
			"\t\treturn sa[i];",
			"\t}",
			"\t",
			"\tconst size_type & at(size_type i) const {",
			"\t\tassert(i <= size());",
			"\t\treturn (*this)[i];",
			"\t}",
			"\t",
			"\tconst std::vector<size_type> & get_sa() const noexcept {",
			"\t\treturn sa;",
			"\t}",
			"\t",
			"\tconst std::vector<size_type> & get_lcp() const noexcept {",
			"\t\treturn lcp;",
			"\t}",
			"\t",
			"\tvoid build(string_type s) {",
			"\t\tthis->s = s;",
			"\t\tsa = sa_is(s);",
			"\t\trank.resize(size() + 1);",
			"\t\tfor (size_type i = 0; i <= size(); ++i) rank[sa[i]] = i;",
			"\t\t",
			"\t\t// LCP 配列の構築",
			"\t\tlcp.resize(size());",
			"\t\tlcp[0] = 0;",
			"\t\tsize_type mtc = 0;",
			"\t\t// lcp[i] := lcp(s[sa[i]], s[sa[i + 1])",
			"\t\tfor (size_type i = 0; i < size(); ++i) {",
			"\t\t\t// lcp[rank[i]] = lcp(s[i..], s[sa[rank[i] + 1])",
			"\t\t\tif (rank[i] == size()) continue;",
			"\t\t\tsize_type k = sa[rank[i] + 1];",
			"\t\t\twhile (i + mtc < size() && k + mtc < size() && s[i + mtc] == s[k + mtc]) ++mtc;",
			"\t\t\tlcp[rank[i]] = mtc;",
			"\t\t\tif (mtc > 0) --mtc;",
			"\t\t}",
			"\t\t",
			"\t\t// セグ木の初期化",
			"\t\tseg_n = 1;",
			"\t\twhile (seg_n < size() + 1) seg_n <<= 1;",
			"\t\tseg.resize(seg_n << 1);",
			"\t\tfor (size_type i = 0; i < size(); ++i) seg[i + seg_n] = lcp[i];",
			"\t\tfor (size_type i = size(); i < seg_n; ++i) seg[i + seg_n] = 0;",
			"\t\tfor (size_type i = seg_n - 1; i > 0; --i) seg[i] = std::min(seg[i << 1], seg[i << 1 | 1]);",
			"\t\t",
			"\t\t// debug 出力",
			"\t\t// for (size_type i = 0; i <= size(); ++i) {",
			"\t\t// \tstd::cout << \"sa[\" << i << \"] = \" << sa[i] << \"\\t, s[sa[i]..] = \" << s.substr(sa[i]);",
			"\t\t// \tif (i < size()) std::cout << \"\\t\\t\\t lcp[i] = \" << lcp[i];",
			"\t\t// \tstd::cout << std::endl;",
			"\t\t// }",
			"\t}",
			"\t",
			"\ttemplate<class S>",
			"\tstatic std::vector<size_type> sa_is(S s, const size_type kind = 128) {",
			"\t\tsize_type n = s.size();",
			"\t\tfor (size_type i = 0; i < n; ++i) ++s[i];",
			"\t\ts.push_back(0);",
			"\t\t",
			"\t\tstd::vector<bool> Stype(n + 1); // true: S-type, false: L-type",
			"\t\tstd::vector<size_type> lms; // LMS-index",
			"\t\tstd::vector<size_type> lms_map(n + 1, n + 1); // [i] := もし i が LMS-index なら lms 配列の index, 違えば n + 1",
			"\t\tstd::vector<size_type> bin(kind + 2); // [i] := count_{j < i} (s[j] = j) => count(s[i] = i]) = bin[i + 1] - bin[i]",
			"\t\t++bin[1];",
			"\t\t",
			"\t\tStype[n] = true;",
			"\t\tfor (size_type i = n; i > 0; --i) {",
			"\t\t\tStype[i - 1] = s[i - 1] == s[i] ? Stype[i] : s[i - 1] < s[i];",
			"\t\t\t++bin[s[i - 1] + 1];",
			"\t\t}",
			"\t\tfor (size_type i = 1; i <= n; ++i) {",
			"\t\t\tif (!Stype[i - 1] && Stype[i]) {",
			"\t\t\t\tlms_map[i] = lms.size();",
			"\t\t\t\tlms.emplace_back(i);",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor (size_type i = 0; i < kind + 1; ++i) bin[i + 1] += bin[i];",
			"\t\t",
			"\t\tstd::vector<size_type> sa, cnt;",
			"\t\t",
			"\t\tauto induce = [&](const std::vector<size_type> &lms) {",
			"\t\t\tsa.assign(n + 1, 0);",
			"\t\t\t",
			"\t\t\tcnt.assign(kind + 1, 0);",
			"\t\t\tfor (size_type i = lms.size(); i > 0; --i) {",
			"\t\t\t\tconst size_type idx = lms[i - 1];",
			"\t\t\t\tconst size_type c = s[idx];",
			"\t\t\t\tsa[bin[c + 1] - cnt[c] - 1] = idx;",
			"\t\t\t\t++cnt[c];",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tcnt.assign(kind + 1, 0);",
			"\t\t\tfor (size_type i = 0; i < n; ++i) {",
			"\t\t\t\tif (sa[i] == 0) continue;",
			"\t\t\t\tconst size_type idx = sa[i] - 1;",
			"\t\t\t\tif (!Stype[idx]) {",
			"\t\t\t\t\tconst size_type c = s[idx];",
			"\t\t\t\t\tsa[bin[c] + cnt[c]] = idx;",
			"\t\t\t\t\t++cnt[c];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tcnt.assign(kind + 1, 0);",
			"\t\t\tfor (size_type i = n; i > 0; --i) {",
			"\t\t\t\tif (sa[i] == 0) continue;",
			"\t\t\t\tconst size_type idx = sa[i] - 1;",
			"\t\t\t\tif (Stype[idx]) {",
			"\t\t\t\t\tconst size_type c = s[idx];",
			"\t\t\t\t\tsa[bin[c + 1] - 1 - cnt[c]] = idx;",
			"\t\t\t\t\t++cnt[c];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t};",
			"\t\t",
			"\t\tinduce(lms);",
			"\t\t",
			"\t\tif (lms.size() >= 2) {",
			"\t\t\tstd::vector<size_type> lms_str(lms.size() - 1); // [i] := lms の index i が何番目(0-indexed) に小さいか(\"\\$\" は無視)",
			"\t\t\tsize_type pre = lms[lms_map[sa[0]]], pre_len = 1, rank = 0;",
			"\t\t\tfor (size_type i = 1; i <= n; ++i) {",
			"\t\t\t\tconst size_type lms_idx = lms_map[sa[i]]; // sa[i] が LMS なら lms の index, 違えば n + 1",
			"\t\t\t\tif (lms_idx == n + 1) continue;",
			"\t\t\t\tconst size_type idx = lms[lms_map[sa[i]]];",
			"\t\t\t\tconst size_type len = lms[lms_idx + 1] - idx + 1;",
			"\t\t\t\t",
			"\t\t\t\t// LMS-substring の s[pre..] と s[idx..] を比較",
			"\t\t\t\tbool issame = pre_len == len;",
			"\t\t\t\tif (issame) {",
			"\t\t\t\t\tfor (size_type j = 0; j < len; ++j) {",
			"\t\t\t\t\t\tif (s[pre + j] != s[idx + j]) {",
			"\t\t\t\t\t\t\tissame = false;",
			"\t\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\trank += !issame;",
			"\t\t\t\tlms_str[lms_idx] = rank - 1;",
			"\t\t\t\t",
			"\t\t\t\tpre = idx;",
			"\t\t\t\tpre_len = len;",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tstd::vector<size_type> new_seed(lms.size());",
			"\t\t\tnew_seed[0] = sa[0];",
			"\t\t\t",
			"\t\t\tif (rank == lms_str.size()) {",
			"\t\t\t\tfor (size_type i = 0; i < lms_str.size(); ++i) new_seed[lms_str[i] + 1] = lms[i];",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tstd::vector<size_type> lms_sa = sa_is(lms_str, rank);",
			"\t\t\t\tfor (size_type i = 1; i < lms_sa.size(); ++i) new_seed[i] = lms[lms_sa[i]];",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tinduce(new_seed);",
			"\t\t}",
			"\t\t",
			"\t\treturn sa;",
			"\t}",
			"\t",
			"\tstd::pair<size_type, size_type> lower_bound(string_type p) const {",
			"\t\tsize_type l = 0, r = seg_n;",
			"\t\tsize_type lplcp = 0, rplcp = 0;",
			"\t\tsize_type seg_idx = 1;",
			"\t\t",
			"\t\twhile (r - l > 1) {",
			"\t\t\tconst size_type m = (l + r) >> 1;",
			"\t\t\tconst size_type lmlcp = seg[seg_idx << 1];",
			"\t\t\tconst size_type rmlcp = seg[seg_idx << 1 | 1];",
			"\t\t\t// std::cout << \"(l, r] = (\" << l << \", \" << r << \"], m = \" << m << \" : lplcp = \" << lplcp << \", rplcp = \" << rplcp << \", lmlcp = \" << lmlcp << \", rmlcp = \" << rmlcp << std::endl;",
			"\t\t\tbool move_r;",
			"\t\t\t",
			"\t\t\tif (lplcp < lmlcp) {",
			"\t\t\t\tmove_r = true;",
			"\t\t\t}",
			"\t\t\telse if (lplcp > lmlcp) {",
			"\t\t\t\tmove_r = false;",
			"\t\t\t\trplcp = lmlcp;",
			"\t\t\t}",
			"\t\t\telse if (rplcp < rmlcp) {",
			"\t\t\t\tmove_r = false;",
			"\t\t\t}",
			"\t\t\telse if (rplcp > rmlcp) {",
			"\t\t\t\tmove_r = true;",
			"\t\t\t\tlplcp = rmlcp;",
			"\t\t\t}",
			"\t\t\telse if (m > size()) {",
			"\t\t\t\tmove_r = false;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tsize_type mplcp = lplcp;",
			"\t\t\t\twhile (sa[m] + mplcp < size() && mplcp < p.size() && s[sa[m] + mplcp] == p[mplcp]) ++mplcp;",
			"\t\t\t\t",
			"\t\t\t\tif (mplcp == p.size() || sa[m] + mplcp < size() && s[sa[m] + mplcp] > p[mplcp]) move_r = false;",
			"\t\t\t\telse move_r = true;",
			"\t\t\t\t(move_r ? lplcp : rplcp) = mplcp;",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tseg_idx <<= 1;",
			"\t\t\tif (move_r) {",
			"\t\t\t\tl = m;",
			"\t\t\t\tseg_idx |= 1;",
			"\t\t\t}",
			"\t\t\telse r = m;",
			"\t\t}",
			"\t\tif (r > size()) r = size() + 1;",
			"\t\treturn {r, rplcp};",
			"\t}",
			"\t",
			"\tsize_type search(string_type p) const {",
			"\t\tconst auto lb = lower_bound(p);",
			"\t\treturn lb.second < p.size() ? size() : sa[lb.first];",
			"\t}",
			"\t",
			"\tstd::vector<size_type> search_all(string_type p) const {",
			"\t\tconst auto lb = lower_bound(p);",
			"\t\tif (lb.second < p.size()) return {};",
			"\t\tsize_type idx = lb.first;",
			"\t\tstd::vector<size_type> res;",
			"\t\tres.emplace_back(sa[idx++]);",
			"\t\tfor (; idx <= size() && lcp[idx - 1] >= p.size(); ++idx) res.emplace_back(sa[idx]);",
			"\t\treturn res;",
			"\t}",
			"\t",
			"private:",
			"\tstring_type s;",
			"\tstd::vector<size_type> sa; // sa[i (<= |s|)] := i 番目に小さい suffix の先頭 index",
			"\tstd::vector<size_type> rank; // [i (<= |s|)] := s[i..] が suffix の中で rank[i] 番目(0-indexed) に小さい",
			"\tstd::vector<size_type> lcp; // [i (< size())] := lcp(s[sa[i]..], s[sa[i + 1]..])",
			"\tsize_type seg_n;",
			"\tstd::vector<size_type> seg;",
			"};\n",
		],
		"description": [
			"SuffixArray(SA-IS, LCP)",
			"https://tkmst201.github.io/Library/String/SuffixArray.hpp",
			"2020/08/25"
		]
	},
}