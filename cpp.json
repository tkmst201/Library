{
	"user": {
		"prefix": "user",
		"body": [
			"/*",
			"** VS Code ユーザースニペット一覧 **",
			"https://github.com/tkmst201/Library の抜粋 + Utility",
			"",
			"last-updated: 2020/11/11",
			"最新版はこちら: https://github.com/tkmst201/Library/blob/master/cpp.json",
			"手動で作成しているので更新し忘れがあるかもしれません",
			"",
			"# Utility (git で管理していない詰め合わせ)",
			"2020/11/10 template: デフォルト実装",
			"2019/11/09 db: if (debug) {}",
			"2019/12/13 pyn: Yes No 出力",
			"2020/08/01 fori: for (i = 0; i < n; ++i) {}",
			"2020/08/01 forr: for (i = n - 1; i >= 0; --i) {}",
			"2020/09/04 compress: 座標圧縮 O(NlogN)", // TODO: compress: cx を生成して返すように変更
			"2020/11/07 compress2: 2 つの vector を合わせた座標圧縮 O(NlogN)", // TODO: compress2: cx を生成して返すように変更
			"2020/11/10 gcd：最大公約数",
			"2020/11/10 lcm：最小公倍数",
			"2020/11/11 prime_factorization: 素因数分解 O(√N)", // TODO: prime_factorization: より高速なものに変更
			"2020/11/13 find_divisor: 約数列挙 O(√N)", // TODO: find_divisor: 整理して git で管理する
			"2020/11/11 sieve: 素数列挙(エラトステネスの篩) O(NloglogN)",
			"2020/11/11 sieve_smallest_prime_factor: [i] := i の最小の素因数 となるようなテーブルを作成 O(n loglog n)",
			"2020/11/11 fast_prime_factorization: smallest_prime_factor テーブルを用いて素因数分解を行う O(log n)",
			"",
			"# DataStructure",
			"2020/09/18 SegmentTree: セグ木",
			"2020/09/16 LazySegmentTree: 遅延伝搬セグ木",
			"2020/08/15 BinaryIndexedTree: BIT",
			"2020/04/22 UnionFind: UnionFind",
			
			"2020/09/07 SuccintBitVector: 簡潔ビットベクトル",
			"2020/09/07 WaveletMatrix: WaveletMatrix",
			"",
			"# GraphTheory",
			"2020/09/18 HeavyLightDecomposition: 重軽分解(LCA 構築: Θ(n loglog n), クエリ: O(loglog n))",
			"2020/09/18 HeavyLightDecomposition_Query: 重軽分解を用いた (パス or 部分木) クエリ処理",
			"2020/10/30 StronglyConnectedComponents: 強連結成分分解",
			"",
			"# Mathematics",
			"2020/02/26 ModInt: 剰余演算",
			"2020/02/26 RuntimeModInt: 実行時 mod 指定 ModInt",
			"2020/02/12 Combination: 組み合わせ, 階乗, 階乗逆元, 逆元 (動的構築)",
			"2020/02/12 Combination_atcoder: 組み合わせ, 階乗, 階乗逆元, 逆元 (動的構築) ac-library ver.",
			"2020/09/21 MathUtility: 便利数学関数詰め合わせ (gcd, lcm, ext_gcd, mod_pow, mod_inv, chinese_remainder)",
			"2020/09/08 enumerate_primes: 素数列挙(高速化されたエラトステネスの篩)",
			"2020/04/13 Matrix: 行列(mint)",
			"2020/11/19 FastFourierTransform: 実数の畳み込み",
			"2020/09/10 TwoSat: 2-SAT ソルバ [StronglyConnectedConponents が必要]",
			"2020/09/11 sum_of_floor_of_linear: Sum_{i = 0}^{N - 1} floor((A * i + B) / M) を求める",
			"2020/11/02 Polynomial: 多項式と 1 次式の乗除",
			"",
			"# String",
			"2020/08/22 RollingHash: ローリングハッシュ",
			"2020/08/25 SuffixArray: SuffixArray(SA-IS, LCP)",
			"*/\n",
		],
		"description": [
			"ユーザスニペット一覧",
			"2020/11/11",
		]
	},
	
	
	/* Utility */
	"template": {
		"prefix": "template",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define FOR(i,a,b) for(int i=(a);i<(b);++i)",
			"#define REP(i,n) FOR(i,0,n)",
			"#define ALL(v) begin(v),end(v)",
			"template<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }",
			"template<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }",
			"using ll = long long;",
			"using pii = pair<int, int>;",
			"constexpr ll INF = 1ll<<30;",
			"constexpr ll longINF = 1ll<<60;",
			"constexpr ll MOD = 1000000007;",
			"constexpr bool debug = 0;",
			"//---------------------------------//",
			"",
			"int main() {",
			"\t$0",
			"\treturn 0;",
			"}",
		],
		"description": [
			"デフォルト実装",
			"2020/11/10",
		]
	},
	
	"debug_output": {
		"prefix": "db",
		"body": [
			"if (debug) {",
			"\t$0",
			"}"
		],
		"description": "デバッグ補助"
	},
	
	"forr": {
		"prefix": "forr",
		"body": "for (${1:int} ${2:i} = ${3:N - 1}; ${2:i} >= ${4:0}; --${2:i}) $0",
		"description": "2020/01/15"
	},
	
	"putsY/N": {
		"prefix": "pyn",
		"body": [
			"puts([&] {",
			"\t$0",
			"}() ? \"Yes\": \"No\");",
		],
		"description": [
			"Yes No 出力",
			"2019/12/13"
		]
	},

	"fori": {
		"prefix": "fori",
		"body": "for (${1:int} ${2:i} = ${3:0}; ${2:i} < ${4:N}; ++${2:i}) $0",
		"description": "2020/01/15"
	},
	
	"compress": {
		"prefix": "compress",
		"body": [
			"auto compress = [](auto &&v, auto &&cv) -> void {",
			"\tfor (auto &&u : v) cv.emplace_back(u);",
			"\tcv.emplace_back(INF);",
			"\tcv.emplace_back(-INF);",
			"\tstd::sort(std::begin(cv), std::end(cv));",
			"\tcv.erase(std::unique(std::begin(cv), std::end(cv)), std::end(cv));",
			"\tfor (auto &&u : v) u = std::lower_bound(std::begin(cv), std::end(cv), u) - std::begin(cv);",
			"};\n",
		],
		"description": [
			"座標圧縮",
			"2020/09/04",
		]
	},
	
	"compress2": {
		"prefix": "compress2",
		"body": [
			"auto compress2 = [](auto &&v1, auto &&v2, auto &&cv) -> void {",
			"\tfor (auto &&u : v1) cv.emplace_back(u);",
			"\tfor (auto &&u : v2) cv.emplace_back(u);",
			"\tcv.emplace_back(INF);",
			"\tcv.emplace_back(-INF);",
			"\tstd::sort(std::begin(cv), std::end(cv));",
			"\tcv.erase(std::unique(std::begin(cv), std::end(cv)), std::end(cv));",
			"\tfor (auto &&u : v1) u = std::lower_bound(std::begin(cv), std::end(cv), u) - std::begin(cv);",
			"\tfor (auto &&u : v2) u = std::lower_bound(std::begin(cv), std::end(cv), u) - std::begin(cv);",
			"};\n",
		],
		"description": [
			"2 つの vector を合わせた座標圧縮",
			"2020/11/07",
		]
	},
	
	"gcd": {
		"prefix":"gcd",
		"body": [
			"ll gcd(ll a, ll b) {",
			"\tif (b == 0) return a;",
			"\treturn gcd(b, a % b);",
			"}\n",
		],
		"description": [
			"最大公約数",
			"2020/11/10",
		]
	},
	
	"lcm": {
		"prefix":"lcm",
		"body": [
			"ll lcm(ll a, ll b) {",
			"\treturn a / gcd(a, b) * b;",
			"}\n",
		],
		"description": [
			"最小公倍数",
			"2020/11/10",
		]
	},
	
	"prime_factorization": {
		"prefix": "prime_factorization",
		"body": [
			"std::vector<std::pair<ll, ll>> prime_factorization(ll n) {",
			"\tstd::vector<std::pair<ll, ll>> res;",
			"\tfor (ll i = 2; i * i <= n; i++) {",
			"\t\tif (n % i == 0) res.emplace_back(i, 1), n /= i;",
			"\t\twhile (n % i == 0) ++res.back().second, n /= i;",
			"\t}",
			"\tif (n > 1) res.emplace_back(n, 1);",
			"\treturn res;",
			"}",
		],
		"description": [
			"素因数分解 O(√N)",
			"2020/11/11",
		]
	},
	
	"find_divisor": {
		"prefix": "find_divisor",
		"body": [
			"std::vector<ll> find_divisor(ll n) {",
			"\tassert(n > 0);",
			"\tstd::vector<ll> divisor;",
			"\tll i = 1;",
			"\tfor (; i * i <= n; i++) if (n % i == 0) divisor.emplace_back(i);",
			"\tint p = divisor.size() - 1;",
			"\tif (divisor[p] * divisor[p]) --p;",
			"\tfor (; p >= 0; --p) divisor.emplace_back(n / divisor[p]);",
			"\treturn divisor;",
			"}\n",
		],
		"description": [
			"約数列挙 O(√N)",
			"2020/11/13",
		]
	},
	
	"sieve": {
		"prefix": "sieve",
		"body": [
			"std::vector<int> sieve(int n) {",
			"\tstd::vector<int> res;",
			"\tstd::vector<bool> is_prime(n + 1, true);",
			"\tis_prime[0] = is_prime[1] = false;",
			"\tfor (int i = 2; i * i <= n; i++) {",
			"\t\tif (!is_prime[i]) continue;",
			"\t\tfor (int j = i * i; j <= n; j += i) is_prime[j] = false;",
			"\t}",
			"\tfor (int i = 2; i <= n; ++i) if (is_prime[i]) res.emplace_back(i);",
			"\treturn res;",
			"}",
		],
		"description": [
			"素数列挙(エラトステネスの篩)",
			"2020/11/11",
		]
	},
	
	"sieve_smallest_prime_factor": {
		"prefix": "sieve_smallest_prime_factor",
		"body": [
			"std::vector<int> sieve_smallest_prime_factor(int n) {",
			"\tassert(n >= 0);",
			"\tstd::vector<int> res(n + 1);",
			"\tstd::iota(begin(res), end(res), 0);",
			"\t",
			"\tfor (int i = 2; i * i <= n; ++i) {",
			"\t\tif (res[i] < i) continue;",
			"\t\tfor (int j = i * i; j <= n; j += i) {",
			"\t\t\tif (res[j] == j) res[j] = i;",
			"\t\t}",
			"\t}",
			"\t",
			"\treturn res;",
			"}\n",
		],
		"description": [
			"[i] := i の最小の素因数 となるようなテーブルを作成 O(n loglog n)",
			"2020/11/11",
		]
	},
	
	"fast_prime_factorization": {
		"prefix": "fast_prime_factorization",
		"body": [
			"std::vector<std::pair<int, int>> fast_prime_factorization(int n, const std::vector<int> & smallest_prime_factor) {",
			"\tassert(n >= 0);",
			"\tassert(n <= smallest_prime_factor.size());",
			"\tstd::vector<std::pair<int, int>> res;",
			"\tfor (; n > 1; n /= smallest_prime_factor[n]) {",
			"\t\tif (res.empty() || res.back().first != smallest_prime_factor[n]) res.emplace_back(smallest_prime_factor[n], 1);",
			"\t\telse ++res.back().second;",
			"\t}",
			"\treturn res;",
			"}\n",
		],
		"description": [
			"smallest_prime_factor テーブルを用いて素因数分解を行う O(log n)",
			"2020/11/11",
		]
	},

	
	/* DataStructure */
	"SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"template<typename T>",
			"struct SegmentTree {",
			"\tusing value_type = T;",
			"\tusing const_reference = const value_type &;",
			"\tusing F = std::function<value_type(const_reference, const_reference)>;",
			"\tusing size_type = std::size_t;",
			"\t",
			"private:",
			"\tsize_type n, n_;",
			"\tvalue_type id_elem;",
			"\tF f;",
			"\tstd::vector<value_type> node;",
			"\t",
			"public:",
			"\tSegmentTree() = default;",
			"\t",
			"\tSegmentTree(size_type n, const_reference id_elem, const F & f) : n(n), id_elem(id_elem), f(f) {",
			"\t\tn_ = 1;",
			"\t\twhile (n_ < n) n_ <<= 1;",
			"\t\tnode.resize(2 * n_, id_elem);",
			"\t}",
			"\t",
			"\tSegmentTree(std::vector<value_type> v, const_reference id_elem, const F & f) :",
			"\t\t\tSegmentTree(v.size(), id_elem, f) {",
			"\t\tfor (size_type i = 0; i < v.size(); ++i) node[i + n_] = v[i];",
			"\t\tfor (size_type i = n_ - 1; i > 0; --i) node[i] = f(node[i << 1], node[i << 1 | 1]);",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvoid set(size_type i, const_reference x) {",
			"\t\tassert(i < size());",
			"\t\tnode[i += n_] = x;",
			"\t\twhile (i > 1) {",
			"\t\t\ti >>= 1;",
			"\t\t\tnode[i] = f(node[i << 1], node[i << 1 | 1]);",
			"\t\t}",
			"\t}",
			"\t",
			"\tconst_reference get(size_type i) const {",
			"\t\tassert(i < size());",
			"\t\treturn node[i + n_];",
			"\t}",
			"\t",
			"\tvalue_type fold(size_type l, size_type r) const {",
			"\t\tassert(l <= r);",
			"\t\tassert(r <= size());",
			"\t\tvalue_type lv = id_elem, rv = id_elem;",
			"\t\tfor (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {",
			"\t\t\tif (l & 1) lv = f(lv, node[l++]);",
			"\t\t\tif (r & 1) rv = f(node[r - 1], rv);",
			"\t\t}",
			"\t\treturn f(lv, rv);",
			"\t}",
			"\t",
			"\tconst_reference fold_all() const {",
			"\t\treturn node[1];",
			"\t}",
			"\t",
			"\tsize_type max_right(size_type l, std::function<bool(const_reference)> g) const {",
			"\t\tassert(l <= size());",
			"\t\tassert(g(id_elem));",
			"\t\tif (l == size()) return size();",
			"\t\tl += n_;",
			"\t\tvalue_type sum = id_elem;",
			"\t\twhile (true) {",
			"\t\t\twhile (~l & 1) l >>= 1;",
			"\t\t\tconst value_type nex_sum = f(sum, node[l]);",
			"\t\t\tif (g(nex_sum)) { sum = nex_sum; ++l; }",
			"\t\t\telse break;",
			"\t\t\tif ((l & -l) == l) return size();",
			"\t\t}",
			"\t\twhile (l < n_) {",
			"\t\t\tconst value_type nex_sum = f(sum, node[l << 1]);",
			"\t\t\tl <<= 1;",
			"\t\t\tif (g(nex_sum)) { sum = nex_sum; l |= 1; }",
			"\t\t}",
			"\t\treturn l - n_;",
			"\t}",
			"\t",
			"\tsize_type min_left(size_type r, std::function<bool(const_reference)> g) const {",
			"\tcassert(r <= size());",
			"\t\tassert(g(id_elem));",
			"\t\tif (r == 0) return 0;",
			"\t\tr += n_;",
			"\t\tvalue_type sum = id_elem;",
			"\t\twhile (true) {",
			"\t\t\t--r;",
			"\t\t\twhile (r > 1 && (r & 1)) r >>= 1;",
			"\t\t\tconst value_type nex_sum = f(node[r], sum);",
			"\t\t\tif (g(nex_sum)) sum = nex_sum;",
			"\t\t\telse break;",
			"\t\t\tif ((r & -r) == r) return 0;",
			"\t\t}",
			"\t\twhile (r < n_) {",
			"\t\t\tconst value_type nex_sum = f(node[r << 1 | 1], sum);",
			"\t\t\tr <<= 1;",
			"\t\t\tif (!g(nex_sum)) r |= 1;",
			"\t\t\telse sum = nex_sum;",
			"\t\t}",
			"\t\treturn r + 1 - n_;",
			"\t}",
			"};\n",
		],
		"description": [
			"セグ木",
			"https://tkmst201.github.io/Library/DataStructure/SegmentTree.hpp",
			"2020/09/18",
		]
	},
	
	"LazySegmentTree": {
		"prefix": "LazySegmentTree",
		"body": [
			"template<typename T, typename E>",
			"struct LazySegmentTree {",
			"\tusing value_type = T;",
			"\tusing lazy_type = E;",
			"\tusing size_type = std::size_t;",
			"\tusing F = std::function<value_type(const value_type &, const value_type &)>; // 要素の merge",
			"\tusing G = std::function<value_type(const value_type &, const lazy_type &)>; // 要素に作用素を作用",
			"\tusing H = std::function<lazy_type(const lazy_type &, const lazy_type &)>; // 作用素の merge",
			"\tusing P = std::function<lazy_type(const lazy_type &, size_type)>; // 区間への作用がその区間の大きさ(k) に比例して変化するとき p(a, k) := g(a, a, ..., a) (k 個)",
			"\t",
			"private:",
			"\tsize_type n, n_, n_log;",
			"\tvalue_type id_node;",
			"\tlazy_type id_lazy;",
			"\tF f;",
			"\tG g;",
			"\tH h;",
			"\tP p;",
			"\tstd::vector<value_type> node;",
			"\tstd::vector<lazy_type> lazy;",
			"",
			"public:",
			"\tLazySegmentTree(size_type n, const value_type & id_node, const lazy_type & id_lazy, const F & f, const G & g, const H & h, const P & p = [](const lazy_type & a, size_type l) { return a; })",
			"\t\t\t: n(n), id_node(id_node), id_lazy(id_lazy), f(f), g(g), h(h), p(p) {",
			"\t\tn_ = 1;",
			"\t\tn_log = 0;",
			"\t\twhile (n_ < n) n_ <<= 1, ++n_log;",
			"\t\tnode.resize(2 * n_, id_node);",
			"\t\tlazy.resize(2 * n_, id_lazy);",
			"\t}",
			"\t",
			"\tLazySegmentTree(const std::vector<value_type> & v, const value_type & id_node, const lazy_type & id_lazy, const F & f, const G & g, const H & h, const P & p = [](const lazy_type & a, size_type l) { return a; })",
			"\t\t\t: LazySegmentTree(v.size(), id_node, id_lazy, f, g, h, p) {",
			"\t\tfor (size_type i = 0; i < v.size(); ++i) node[i + n_] = v[i];",
			"\t\tfor (size_type i = n_ - 1; i > 0; --i) node[i] = f(node[i << 1], node[i << 1 | 1]);",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvoid set(size_type k, const value_type & x) {",
			"\t\tassert(k < size());",
			"\t\tk += n_;",
			"\t\tthrust(k);",
			"\t\tnode[k] = x;",
			"\t\tlazy[k] = id_lazy;",
			"\t\trecalc(k);",
			"\t}",
			"\t",
			"\tvalue_type get(size_type k) {",
			"\t\tassert(k < size());",
			"\t\tk += n_;",
			"\t\tthrust(k);",
			"\t\treturn reflect(k, 1);",
			"\t}",
			"\t",
			"\tvoid update(size_type l, size_type r, const lazy_type & x) {",
			"\t\tassert(l <= r);",
			"\t\tassert(r <= size());",
			"\t\tif (l == r) return;",
			"\t\tl += n_;",
			"\t\tr += n_;",
			"\t\tthrust(l);",
			"\t\tthrust(r - 1);",
			"\t\tfor(size_type cl = l, cr = r; cl < cr; cl >>= 1, cr >>= 1) {",
			"\t\t\tif (cl & 1) lazy[cl] = h(lazy[cl], x), ++cl;",
			"\t\t\tif (cr & 1) --cr, lazy[cr] = h(lazy[cr], x);",
			"\t\t}",
			"\t\trecalc(l);",
			"\t\trecalc(r - 1);",
			"\t\treturn;",
			"\t}",
			"\t",
			"\tvalue_type fold(size_type l, size_type r) {",
			"\t\tassert(l <= r);",
			"\t\tassert(r <= size());",
			"\t\tif (l == r) return id_node;",
			"\t\tl += n_;",
			"\t\tr += n_;",
			"\t\tthrust(l);",
			"\t\tthrust(r - 1);",
			"\t\tvalue_type vl = id_node, vr = id_node;",
			"\t\tfor (size_type w = 1; l < r; l >>= 1, r >>= 1, w <<= 1) {",
			"\t\t\tif (l & 1) vl = f(vl, reflect(l, w)), ++l;",
			"\t\t\tif (r & 1) --r, vr = f(reflect(r, w), vr);",
			"\t\t}",
			"\t\treturn f(vl, vr);",
			"\t}",
			"\t",
			"\tvalue_type fold_all() const {",
			"\t\treturn node[1];",
			"\t}",
			"\t",
			"private:",
			"\tvalue_type reflect(size_type k, size_type w) {",
			"\t\treturn lazy[k] == id_lazy ? node[k] : g(node[k], p(lazy[k], w));",
			"\t}",
			"\t",
			"\tvoid propagate(size_type k, size_type w) {",
			"\t\tif (lazy[k] == id_lazy) return;",
			"\t\tif ((k << 1 | 1) < node.size()) {",
			"\t\t\tlazy[k << 1] = h(lazy[k << 1], lazy[k]);",
			"\t\t\tlazy[k << 1 | 1] = h(lazy[k << 1 | 1], lazy[k]);",
			"\t\t}",
			"\t\tnode[k] = reflect(k, w); // g(node[k], p(lazy[k], l));",
			"\t\tlazy[k] = id_lazy;",
			"\t}",
			"\t",
			"\tvoid recalc(size_type k) {",
			"\t\tfor (size_type i = k >> 1, cw = 1; i > 0; i >>= 1, cw <<= 1)",
			"\t\t\tnode[i] = f(reflect(i << 1, cw), reflect(i << 1 | 1, cw));",
			"\t}",
			"\t",
			"\tvoid thrust(size_type k) {",
			"\t\tfor (size_type i = n_log, w = n_; i > 0; --i, w >>= 1) propagate(k >> i, w);",
			"\t}",
			"};\n",
		],
		"description": [
			"遅延伝搬セグ木",
			"https://tkmst201.github.io/Library/DataStructure/LazySegmentTree.hpp",
			"2020/09/16",
		]
	},
	
	"BinaryIndexedTree": {
		"prefix": "BinaryIndexedTree",
		"body": [
			"template<typename T>",
			"struct BinaryIndexedTree {",
			"\tusing value_type = T;",
			"\tusing const_reference = const value_type &;",
			"\tusing F = std::function<value_type(const_reference, const_reference)>;",
			"\tusing size_type = std::size_t;",
			"\t",
			"\tBinaryIndexedTree(size_type n, const F & f, const_reference id_elem) : n(n), f(f), id_elem(id_elem) {",
			"\t\tnode.resize(n + 1, id_elem);",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvoid add(size_type i, const_reference x) {",
			"\t\tassert(i < size());",
			"\t\t++i;",
			"\t\tfor (; i <= size(); i += i & -i) node[i] = f(node[i], x);",
			"\t}",
			"\t",
			"\t// [0, i)",
			"\tvalue_type sum(size_type i) const {",
			"\t\tassert(i <= size());",
			"\t\tvalue_type res = id_elem;",
			"\t\tfor (; i > 0; i -= i & -i) res = f(res, node[i]);",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\t// sum[0, r] <= x を満たす最小の r を返す (存在しなければ size())",
			"\tsize_type lower_bound(const_reference x) const {",
			"\t\tsize_type res = 0;",
			"\t\tsize_type s = id_elem, w = 1;",
			"\t\twhile (w < size()) w <<= 1;",
			"\t\tfor (; w > 0; w >>= 1) {",
			"\t\t\tif (res + w <= size()) {",
			"\t\t\t\tvalue_type cur = f(s, node[res + w]);",
			"\t\t\t\tif (cur < x) {",
			"\t\t\t\t\tres += w;",
			"\t\t\t\t\ts = cur;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"private:",
			"\tsize_type n;",
			"\tF f;",
			"\tvalue_type id_elem;",
			"\tstd::vector<value_type> node;",
			"};\n",
		],
		"description": [
			"BIT",
			"https://tkmst201.github.io/Library/DataStructure/BinaryIndexedTree2D.hpp",
			"2020/08/15",
		]
	},
	
	"UnionFind": {
		"prefix": "UnionFind",
		"body": [
			"struct UnionFind {",
			"public:",
			"\tusing size_type = std::size_t;",
			"\t",
			"\tUnionFind(size_type n) : n(n), size_(n, 1) {",
			"\t\tpar.resize(n);",
			"\t\tstd::iota(par.begin(), par.end(), 0);",
			"\t}",
			"\t",
			"\tsize_type size(size_type x) { return size_[find(x)]; }",
			"\t",
			"\tsize_type find(size_type x) {",
			"\t\tassert(x < n);",
			"\t\twhile (par[x] != x) {",
			"\t\t\tpar[x] = par[par[x]];",
			"\t\t\tx = par[x];",
			"\t\t}",
			"\t\treturn x;",
			"\t}",
			"\t",
			"\tvoid unite(size_type x, size_type y) {",
			"\t\tx = find(x);",
			"\t\ty = find(y);",
			"\t\tif (x == y) return;",
			"\t\tif (size(x) > size(y)) std::swap(x, y);",
			"\t\tpar[x] = y;",
			"\t\tsize_[y] += size_[x];",
			"\t}",
			"\t",
			"\tbool issame(size_type x, size_type y) { return find(x) == find(y); }",
			"\t",
			"private:",
			"\tsize_type n;",
			"\tstd::vector<size_type> size_, par;",
			"};\n",
		],
		"description": [
			"UnionFind",
			"https://tkmst201.github.io/Library/DataStructure/UnionFind.hpp",
			"2020/04/22",
		]
	},
	
	"SuccintBitVector": {
		"prefix": "SuccintBitVector",
		"body": [
			"struct SuccintBitVector {",
			"\tusing size_type = std::size_t;",
			"\tusing uint16 = std::uint16_t;",
			"\tusing uint32 = std::uint32_t;",
			"\tusing uint64 = std::uint64_t;",
			"\t",
			"private:",
			"\t// optimized n = 2^16",
			"\tstatic constexpr size_type LARGE = 8; // bits, log^2 n",
			"\tstatic constexpr size_type SMALL = 3; // bits, (log n) / 2",
			"\tstatic constexpr size_type DAT_B = 6; // bits (2^6 = 64 bit)",
			"\tstatic constexpr size_type SMALL_S = 1ull << (1ull << SMALL);",
			"\t",
			"private:",
			"\tsize_type n;",
			"\tstd::vector<uint64> bits;",
			"\tstd::vector<uint32> large;",
			"\tstd::vector<uint16> small;",
			"\t",
			"\tstatic const uint16 table[SMALL_S];",
			"\t",
			"public:",
			"\tSuccintBitVector(size_type n) {",
			"\t\tassert(n > 0);",
			"\t\tn = (n + (1u << LARGE) - 1) >> LARGE << LARGE;",
			"\t\tthis->n = n;",
			"\t\tbits.resize((n >> DAT_B) + 1);",
			"\t}",
			"\t",
			"\tSuccintBitVector(const std::vector<uint64> & v) {",
			"\t\tassert(!v.empty());",
			"\t\tn = ((v.size() << DAT_B) + (1u << LARGE) - 1) >> LARGE << LARGE;",
			"\t\tbits.resize((n >> DAT_B) + 1);",
			"\t\tstd::copy(std::begin(v), std::end(v), std::begin(bits));",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvoid set(size_type i) {",
			"\t\tbits[i >> DAT_B] |= 1ull << (i & ((1u << DAT_B) - 1));",
			"\t}",
			"\t",
			"\tbool access(size_type i) const {",
			"\t\treturn bits[i >> DAT_B] >> (i & ((1u << DAT_B) - 1)) & 1;",
			"\t}",
			"\t",
			"\tsize_type rank1(size_type i) const {",
			"\t\treturn large[i >> LARGE] + small[i >> SMALL]",
			"\t\t\t+ pop_count(",
			"\t\t\t\tget_val(bits[i >> DAT_B], (i & ((1u << DAT_B) - 1)) >> SMALL)",
			"\t\t\t\t\t& ((1u << (i & ((1u << SMALL) - 1))) - 1) );",
			"\t\t// (i >> DAT_B) < bits.size() となるように +1 余分に確保",
			"\t}",
			"\t",
			"\tsize_type rank0(size_type i) const {",
			"\t\treturn i - rank1(i);",
			"\t}",
			"\t",
			"\tsize_type select1(size_type k) const {",
			"\t\tif (k == 0) return 0;",
			"\t\t",
			"\t\tsize_type l = 0, r = large.size() - 1; // (l, r]",
			"\t\twhile (r - l > 1) {",
			"\t\t\tsize_type m = (l + r) >> 1;",
			"\t\t\t(large[m] >= k ? r : l) = m;",
			"\t\t}",
			"\t\t",
			"\t\tsize_type res = (r - 1) << LARGE;",
			"\t\tk -= large[r - 1];",
			"\t\tsize_type base = (r - 1) << (LARGE - SMALL);",
			"\t\tl = 0; r = 1u << (LARGE - SMALL);",
			"\t\twhile (r - l > 1) {",
			"\t\t\tsize_type m = (l + r) >> 1;",
			"\t\t\t(small[base + m] >= k ? r : l) = m;",
			"\t\t}",
			"\t\t",
			"\t\tres += (r - 1) << SMALL;",
			"\t\tbase += r - 1;",
			"\t\tk -= small[base];",
			"\t\tbase >>= DAT_B - SMALL;",
			"\t\tfor (size_type idx = ((r - 1) & ((1u << SMALL) - 1)) << SMALL; k; ++idx, ++res) {",
			"\t\t\tif (bits[base] >> idx & 1) --k;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tsize_type select0(size_type k) const {",
			"\t\tif (k == 0) return 0;",
			"\t\t",
			"\t\tsize_type l = 0, r = large.size() - 1; // (l, r]",
			"\t\twhile (r - l > 1) {",
			"\t\t\tsize_type m = (l + r) >> 1;",
			"\t\t\t((1u << LARGE) * m - large[m] >= k ? r : l) = m;",
			"\t\t}",
			"\t\t",
			"\t\tsize_type res = (r - 1) << LARGE;",
			"\t\tk -= (1u << LARGE) * (r - 1) - large[r - 1];",
			"\t\tsize_type base = (r - 1) << (LARGE - SMALL);",
			"\t\tl = 0; r = 1u << (LARGE - SMALL);",
			"\t\twhile (r - l > 1) {",
			"\t\t\tsize_type m = (l + r) >> 1;",
			"\t\t\t((1u << SMALL) * m - small[base + m] >= k ? r : l) = m;",
			"\t\t}",
			"\t\t",
			"\t\tres += (r - 1) << SMALL;",
			"\t\tbase += r - 1;",
			"\t\tk -= (1u << SMALL) * (r - 1) - small[base];",
			"\t\tbase >>= DAT_B - SMALL;",
			"\t\tfor (size_type idx = ((r - 1) & ((1u << SMALL) - 1)) << SMALL; k; ++idx, ++res) {",
			"\t\t\tif (~bits[base] >> idx & 1) --k;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tvoid build() {",
			"\t\tlarge.assign((n >> LARGE) + 1, 0);",
			"\t\tsmall.assign((n >> SMALL) + 1, 0);",
			"\t\t",
			"\t\tfor (size_type i = 0, small_idx = 1; i < bits.size() - 1; ++i) {",
			"\t\t\tif ((i & ((1u << (LARGE - DAT_B)) - 1)) == 0) small[small_idx] = pop_count(get_val(bits[i], 0));",
			"\t\t\telse small[small_idx] = small[small_idx - 1] + pop_count(get_val(bits[i], 0));",
			"\t\t\t++small_idx;",
			"\t\t\t",
			"\t\t\tfor (size_type j = 1; j < (1u << (DAT_B - SMALL)); ++j, ++small_idx)",
			"\t\t\t\tsmall[small_idx] = small[small_idx - 1] + pop_count(get_val(bits[i], j));",
			"\t\t}",
			"\t\t",
			"\t\tfor (size_type i = 1; i < large.size(); ++i) {",
			"\t\t\tlarge[i] = large[i - 1] + small[i << (LARGE - SMALL)];",
			"\t\t\tsmall[i << (LARGE - SMALL)] = 0;",
			"\t\t}",
			"\t}",
			"\t",
			"private:",
			"\tuint16 get_val(uint64 x, size_type i) const {",
			"\t\treturn x >> ((1u << SMALL) * i) & (SMALL_S - 1);",
			"\t}",
			"\t",
			"\tuint16 pop_count(uint16 x) const {",
			"\t\treturn table[x];",
			"\t}",
			"};",
			"",
			"constexpr SuccintBitVector::uint16 SuccintBitVector::table[256] = {",
			"\t0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,",
			"\t1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,",
			"\t1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,",
			"\t2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,",
			"\t1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,",
			"\t2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,",
			"\t2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,",
			"\t3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,",
			"\t1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,",
			"\t2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,",
			"\t2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,",
			"\t3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,",
			"\t2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,",
			"\t3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,",
			"\t3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,",
			"\t4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8,",
			"};\n",
		],
		"description": [
			"SuccintBitVector",
			"https://tkmst201.github.io/Library/DataStructure/SuccintBitVector.hpp",
			"2020/09/07",
		]
	},
	
	"WaveletMatrix": {
		"prefix": "WaveletMatrix",
		"body": [
			"template<std::size_t BITS, typename T, class BV>",
			"struct WaveletMatrix {",
			"\tstatic_assert(BITS > 0, \"BITS > 0\");",
			"\t",
			"\tusing size_type = std::size_t;",
			"\tusing value_type = T;",
			"\tusing bv_type = BV;",
			"\tusing const_reference = const value_type &;",
			"\t",
			"private:",
			"\tsize_type n;",
			"\tstd::vector<bv_type> bit_vector;",
			"\tstd::vector<size_type> zero;",
			"\t",
			"public:",
			"\tWaveletMatrix(const std::vector<value_type> &v) {",
			"\t\tbuild(v);",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvalue_type access(size_type k) const {",
			"\t\tassert(k < size());",
			"\t\t",
			"\t\tvalue_type res = 0;",
			"\t\tfor (size_type i = BITS; i > 0; --i) {",
			"\t\t\tconst size_type b = i - 1;",
			"\t\t\tif (bit_vector[b].access(k)) {",
			"\t\t\t\tres |= 1ull << b;",
			"\t\t\t\tk = bit_vector[b].rank1(k) + zero[b];",
			"\t\t\t}",
			"\t\t\telse k = bit_vector[b].rank0(k);",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tstd::tuple<size_type, size_type, size_type> rank_all(size_type l, size_type r, const_reference x) const {",
			"\t\tassert(r <= size());",
			"\t\tassert((x >> BITS) == 0);",
			"\t\tif (l >= r) return std::make_tuple(0, 0, 0);",
			"\t\t",
			"\t\tsize_type rank_lt = 0, rank_mt = 0;",
			"\t\tfor (size_type i = BITS; i > 0; --i) {",
			"\t\t\tsize_type b = i - 1;",
			"\t\t\tconst size_type l1 = bit_vector[b].rank1(l), r1 = bit_vector[b].rank1(r);",
			"\t\t\tif (x >> b & 1) {",
			"\t\t\t\trank_lt += (r - r1) - (l - l1);",
			"\t\t\t\tl = l1 + zero[b];",
			"\t\t\t\tr = r1 + zero[b];",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\trank_mt += r1 - l1;",
			"\t\t\t\tl -= l1;",
			"\t\t\t\tr -= r1;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn std::make_tuple(rank_lt, r - l, rank_mt);",
			"\t}",
			"\t",
			"\tsize_type rank_less_than(size_type l, size_type r, const_reference x) const {",
			"\t\treturn std::get<0>(rank_all(l, r, x));",
			"\t}",
			"\t",
			"\tsize_type rank(size_type l, size_type r, const_reference x) const {",
			"\t\treturn std::get<1>(rank_all(l, r, x));",
			"\t}",
			"\t",
			"\tsize_type rank_more_than(size_type l, size_type r, const_reference x) const {",
			"\t\treturn std::get<2>(rank_all(l, r, x));",
			"\t}",
			"\t",
			"\tsize_type select(size_type k, const_reference x) const {",
			"\t\tassert(k <= size());",
			"\t\tassert((x >> BITS) == 0);",
			"\t\tif (k == 0) return 0;",
			"\t\t",
			"\t\tsize_type pos = 0;",
			"\t\tfor (size_type i = BITS; i > 0; --i) {",
			"\t\t\tconst size_type b = i - 1;",
			"\t\t\tif (x >> b & 1) pos = bit_vector[b].rank1(pos) + zero[b];",
			"\t\t\telse pos = bit_vector[b].rank0(pos);",
			"\t\t}",
			"\t\tpos += k - 1;",
			"\t\tif (pos >= size()) return size() + 1;",
			"\t\t",
			"\t\tfor (size_type i = 0; i < BITS; ++i) {",
			"\t\t\tsize_type npos;",
			"\t\t\tif (x >> i & 1) {",
			"\t\t\t\tif (pos < zero[i]) return size() + 1;",
			"\t\t\t\tnpos = bit_vector[i].select1(pos - zero[i] + 1);",
			"\t\t\t}",
			"\t\t\telse npos = bit_vector[i].select0(pos + 1);",
			"\t\t\t",
			"\t\t\tif (npos > size()) return size() + 1;",
			"\t\t\tpos = npos - 1;",
			"\t\t}",
			"\t\treturn pos + 1;",
			"\t}",
			"\t",
			"\tvalue_type quantile(size_type l, size_type r, size_type k) const {",
			"\t\tassert(l < r);",
			"\t\tassert(r <= size());",
			"\t\tassert(0 < k);",
			"\t\tassert(k <= r - l);",
			"\t\t",
			"\t\tvalue_type res = 0;",
			"\t\tfor (size_type i = BITS; i > 0; --i) {",
			"\t\t\tconst size_type b = i - 1;",
			"\t\t\tconst size_type l1 = bit_vector[b].rank1(l), r1 = bit_vector[b].rank1(r);",
			"\t\t\tconst size_type c = (r - r1) - (l - l1);",
			"\t\t\t",
			"\t\t\tif (k <= c) {",
			"\t\t\t\tl -= l1;",
			"\t\t\t\tr -= r1;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tl = l1 + zero[b];",
			"\t\t\t\tr = r1 + zero[b];",
			"\t\t\t\tk -= c;",
			"\t\t\t\tres |= 1ull << b;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tsize_type range_frequency(size_type l, size_type r, value_type val_l, value_type val_r) const {",
			"\t\tassert(r <= size());",
			"\t\tassert(((val_r - 1) >> BITS) == 0);",
			"\t\tif (l >= r || val_l >= val_r) return 0;",
			"\t\treturn rank_less_than(l, r, val_r) - rank_less_than(l, r, val_l);",
			"\t}",
			"\t",
			"\tstd::vector<std::pair<value_type, size_type>> range_min_k",
			"\t\t(size_type l, size_type r, value_type val_l, value_type val_r, size_type k) const {",
			"\t\tassert(r <= size());",
			"\t\tassert(((val_r - 1) >> BITS) == 0);",
			"\t\tif (l >= r || val_l >= val_r || k == 0) return {};",
			"\t\t",
			"\t\tstd::vector<std::pair<value_type, size_type>> res;",
			"\t\tstruct Data {",
			"\t\t\tsize_type i, l, r;",
			"\t\t\tbool ismin;",
			"\t\t\tvalue_type val;",
			"\t\t\tData(size_type i, size_type l, size_type r, bool ismin, value_type val)",
			"\t\t\t\t: i(i), l(l), r(r), ismin(ismin), val(val) {}",
			"\t\t};",
			"\t\t",
			"\t\tstd::stack<Data> stk;",
			"\t\tstk.emplace(BITS, l, r, true, 0);",
			"\t\t",
			"\t\twhile (!stk.empty()) {",
			"\t\t\tconst Data dat = stk.top(); stk.pop();",
			"\t\t\tif (dat.i == 0) {",
			"\t\t\t\tif (dat.val < val_r) {",
			"\t\t\t\t\tres.emplace_back(dat.val, dat.r - dat.l);",
			"\t\t\t\t\tif (res.size() == k) break;",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\t}",
			"\t\t\t\telse break;",
			"\t\t\t}",
			"\t\t\tconst size_type b = dat.i - 1;",
			"\t\t\tconst size_type l1 = bit_vector[b].rank1(dat.l), r1 = bit_vector[b].rank1(dat.r);",
			"\t\t\t",
			"\t\t\tconst bool bit = val_l >> b & 1;",
			"\t\t\tif (l1 != r1) stk.emplace(b, l1 + zero[b], r1 + zero[b], dat.ismin & bit, dat.val | (1ull << b));",
			"\t\t\tif (!(dat.ismin && bit)) {",
			"\t\t\t\tconst size_type l0 = dat.l - l1, r0 = dat.r - r1;",
			"\t\t\t\tif (l0 != r0) stk.emplace(b, l0, r0, dat.ismin, dat.val);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tstd::vector<std::pair<value_type, size_type>> range_max_k",
			"\t\t(size_type l, size_type r, value_type val_l, value_type val_r, size_type k) const {",
			"\t\tassert(r <= size());",
			"\t\tassert(((val_r - 1) >> BITS) == 0);",
			"\t\tif (l >= r || val_l >= val_r || k == 0) return {};",
			"\t\t--val_r;",
			"\t\t",
			"\t\tstd::vector<std::pair<value_type, size_type>> res;",
			"\t\tstruct Data {",
			"\t\t\tsize_type i, l, r;",
			"\t\t\tbool ismax;",
			"\t\t\tvalue_type val;",
			"\t\t\tData(size_type i, size_type l, size_type r, bool ismax, value_type val)",
			"\t\t\t\t: i(i), l(l), r(r), ismax(ismax), val(val) {}",
			"\t\t};",
			"\t\t",
			"\t\tstd::stack<Data> stk;",
			"\t\tstk.emplace(BITS, l, r, true, 0);",
			"\t\t",
			"\t\twhile (!stk.empty()) {",
			"\t\t\tconst Data dat = stk.top(); stk.pop();",
			"\t\t\tif (dat.i == 0) {",
			"\t\t\t\tif (dat.val >= val_l) {",
			"\t\t\t\t\tres.emplace_back(dat.val, dat.r - dat.l);",
			"\t\t\t\t\tif (res.size() == k) break;",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\t}",
			"\t\t\t\telse break;",
			"\t\t\t}",
			"\t\t\tconst size_type b = dat.i - 1;",
			"\t\t\tconst size_type l1 = bit_vector[b].rank1(dat.l), r1 = bit_vector[b].rank1(dat.r);",
			"\t\t\t",
			"\t\t\tconst bool bit = val_r >> b & 1;",
			"\t\t\tconst size_type l0 = dat.l - l1, r0 = dat.r - r1;",
			"\t\t\tif (l0 != r0) stk.emplace(b, l0, r0, dat.ismax & !bit, dat.val);",
			"\t\t\tif (!(dat.ismax & !bit) && l1 != r1) stk.emplace(b, l1 + zero[b], r1 + zero[b], dat.ismax, dat.val | (1ull << b));",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tstd::pair<value_type, bool> next_value(size_type l, size_type r, value_type val_l, value_type val_r) const {",
			"\t\tconst auto res = range_min_k(l, r, val_l, val_r, 1);",
			"\t\tif (res.empty()) return {0, false};",
			"\t\treturn {res[0].first, true};",
			"\t}",
			"\t",
			"\tstd::pair<value_type, bool> prev_value(size_type l, size_type r, value_type val_l, value_type val_r) const {",
			"\t\tconst auto res = range_max_k(l, r, val_l, val_r, 1);",
			"\t\tif (res.empty()) return {0, false};",
			"\t\treturn {res[0].first, true};",
			"\t}",
			"\t",
			"\tstd::vector<std::pair<size_type, value_type>> get_rect(size_type l, size_type r, value_type val_l, value_type val_r) const {",
			"\t\tauto points = range_min_k(l, r, val_l, val_r, r - l);",
			"\t\tstd::vector<std::pair<size_type, value_type>> res;",
			"\t\tfor (auto &p : points) {",
			"\t\t\tconst size_type c = rank(0, l, p.first);",
			"\t\t\tfor (size_type i = 0; i < p.second; ++i) res.emplace_back(select(c + i + 1, p.first) - 1, p.first);",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"private:",
			"\tvoid build(const std::vector<value_type> &v) {",
			"\t\tassert(!v.empty());",
			"\t\tn = v.size();",
			"\t\tfor (size_type i = 0; i < n; ++i) assert((v[i] >> BITS) == 0);",
			"\t\t",
			"\t\tbit_vector.resize(BITS, bv_type{n});",
			"\t\tzero.resize(BITS, 0);",
			"\t\t",
			"\t\tstd::vector<size_type> ord(n), nex_ord;",
			"\t\tstd::iota(std::begin(ord), std::end(ord), 0);",
			"\t\t",
			"\t\tfor (size_type i = BITS - 1; i >= 0; --i) {",
			"\t\t\tnex_ord.assign(n, 0);",
			"\t\t\tfor (size_type j = 0; j < n; ++j) {",
			"\t\t\t\tif (v[ord[j]] >> i & 1) bit_vector[i].set(j);",
			"\t\t\t\telse ++zero[i];",
			"\t\t\t}",
			"\t\t\tif (i == 0) break; // 最後は sort しない",
			"\t\t\t",
			"\t\t\tsize_type p0 = 0, p1 = zero[i];",
			"\t\t\tfor (size_type j = 0; j < n; ++j) {",
			"\t\t\t\tif (v[ord[j]] >> i & 1) nex_ord[p1++] = ord[j];",
			"\t\t\t\telse nex_ord[p0++] = ord[j];",
			"\t\t\t}",
			"\t\t\tstd::swap(ord, nex_ord);",
			"\t\t}",
			"\t\t",
			"\t\tfor (size_type i = 0; i < BITS; ++i) bit_vector[i].build();",
			"\t}",
			"};\n",
		],
		"description": [
			"WaveletMatrix",
			"https://tkmst201.github.io/Library/DataStructure/WaveletMatrix.hpp",
			"2020/09/07",
		]
	},
	
	
	/* GraphTheory */
	"HeavyLightDecomposition": {
		"prefix": "HeavyLightDecomposition",
		"body": [
			"struct HeavyLightDecomposition {",
			"\tusing size_type = std::uint_fast32_t;",
			"\tusing Graph = std::vector<std::vector<size_type>>;",
			"\t",
			"private:",
			"\tsize_type bf_n; // グラフの頂点数",
			"\t",
			"\tstd::vector<size_type> par_; // [v] := 頂点 v の親の頂点番号(存在しなければ自分自身)",
			"\tstd::vector<size_type> sub_size_; // [v] := 頂点 v を根とする部分木のサイズ",
			"\tstd::vector<size_type> depth_; // [v] := 頂点 v の元のグラフでの深さ",
			"\t",
			"\tstd::vector<size_type> tree_id_; // [v] := 頂点 v が属する木の id",
			"\tstd::vector<size_type> roots_; // [i] := i 番目の木の root",
			"\t",
			"\tstd::vector<size_type> heavy_map_; // [v] := 頂点 v が属する heavy-path id",
			"\tstd::vector<size_type> head_; // [i] := heavy-path i の最も根に近い頂点番号",
			"\tstd::vector<size_type> heavy_size_ ; // [i] := heavy-path i に属する頂点の個数",
			"\tstd::vector<size_type> heavy_depth_; // [i] := heavy-path i から根までに通る light-edge の個数",
			"\t",
			"\t// euler-tour",
			"\tstd::vector<size_type> in_; // [v] := 頂点 v の EulerTour 順序(同一 heavy-path 内では連続)",
			"\tstd::vector<size_type> out_; // [v] := 頂点 v から出るときの EulerTour 順序",
			"\tstd::vector<size_type> euler_map_; // [i] := EulerTour 順序が i であるような頂点",
			"\t",
			"\t// heavy-path doubling",
			"\tstd::vector<std::vector<size_type>> par_dblng_; // [k][i] := heavy-path i から 2^k 回 light-edge を上った先の頂点",
			"\t",
			"public:",
			"\tHeavyLightDecomposition(const Graph & g, bool use_lca = false) : HeavyLightDecomposition(g, g.size(), use_lca) {}",
			"\tHeavyLightDecomposition(const Graph & g, size_type root, bool use_lca) : bf_n(g.size()) {",
			"\t\tpar_.resize(bf_size());",
			"\t\tsub_size_.resize(bf_size());",
			"\t\tdepth_.resize(bf_size());",
			"\t\ttree_id_.assign(bf_size(), bf_size());",
			"\t\tstd::vector<size_type> next(bf_size()); // [v] := 頂点 v と同一 heavy-path 内で v より 1 つ葉側の頂点(存在しなければ自分自身)",
			"\t\t",
			"\t\tfor (size_type i = 0; i < bf_size(); ++i) {",
			"\t\t\tif (tree_id_[i] != bf_size()) continue;",
			"\t\t\tif (root != bf_size() && i != root) continue;",
			"\t\t\t",
			"\t\t\tstd::stack<std::pair<size_type, size_type>> stk;",
			"\t\t\tpar_[i] = i;",
			"\t\t\tdepth_[i] = 0;",
			"\t\t\ttree_id_[i] = roots_.size();",
			"\t\t\tstk.emplace(i, 0);",
			"\t\t\t",
			"\t\t\twhile (!stk.empty()) {",
			"\t\t\t\tconst size_type u = stk.top().first, i = stk.top().second; stk.pop();",
			"\t\t\t\tif (i < g[u].size()) {",
			"\t\t\t\t\tstk.emplace(u, i + 1);",
			"\t\t\t\t\tconst size_type v = g[u][i];",
			"\t\t\t\t\tif (v == par_[u]) continue;",
			"\t\t\t\t\tpar_[v] = u;",
			"\t\t\t\t\tdepth_[v] = depth_[u] + 1;",
			"\t\t\t\t\ttree_id_[v] = roots_.size();",
			"\t\t\t\t\tstk.emplace(v, 0);",
			"\t\t\t\t}",
			"\t\t\t\telse {",
			"\t\t\t\t\tsize_type mx = 0;",
			"\t\t\t\t\tnext[u] = u;",
			"\t\t\t\t\tsub_size_[u] = 1;",
			"\t\t\t\t\tfor (size_type v : g[u]) {",
			"\t\t\t\t\t\tif (v == par_[u]) continue;",
			"\t\t\t\t\t\tsub_size_[u] += sub_size_[v];",
			"\t\t\t\t\t\tif (mx < sub_size_[v]) {",
			"\t\t\t\t\t\t\tmx = sub_size_[v];",
			"\t\t\t\t\t\t\tnext[u] = v;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\troots_.emplace_back(i);",
			"\t\t}",
			"\t\t",
			"\t\theavy_map_.resize(bf_size());",
			"\t\tin_.resize(bf_size());",
			"\t\tout_.resize(bf_size());",
			"\t\teuler_map_.reserve(bf_size());",
			"\t\t",
			"\t\tfor (size_type root : roots_) {",
			"\t\t\tstd::stack<std::pair<size_type, size_type>> stk;",
			"\t\t\t",
			"\t\t\theavy_map_[root] = head_.size();",
			"\t\t\thead_.emplace_back(root);",
			"\t\t\theavy_size_.emplace_back(1);",
			"\t\t\theavy_depth_.emplace_back(0);",
			"\t\t\tstk.emplace(root, 0);",
			"\t\t\t",
			"\t\t\twhile (!stk.empty()) {",
			"\t\t\t\tconst size_type u = stk.top().first, i = stk.top().second; stk.pop();",
			"\t\t\t\tif (i < g[u].size()) {",
			"\t\t\t\t\tstk.emplace(u, i + 1);",
			"\t\t\t\t\tconst size_type v = g[u][i];",
			"\t\t\t\t\tif (v != par_[u] && v != next[u]) {",
			"\t\t\t\t\t\theavy_map_[v] = head_.size();",
			"\t\t\t\t\t\thead_.emplace_back(v);",
			"\t\t\t\t\t\theavy_size_.emplace_back(1);",
			"\t\t\t\t\t\theavy_depth_.emplace_back(heavy_depth_[heavy_map_[u]] + 1);",
			"\t\t\t\t\t\tstk.emplace(v, 0);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\tif (i == 0) {",
			"\t\t\t\t\tin_[u] = euler_map_.size();",
			"\t\t\t\t\teuler_map_.emplace_back(u);",
			"\t\t\t\t\tconst size_type v = next[u];",
			"\t\t\t\t\tif (v != u) {",
			"\t\t\t\t\t\theavy_map_[v] = heavy_map_[u];",
			"\t\t\t\t\t\t++heavy_size_[heavy_map_[u]];",
			"\t\t\t\t\t\tstk.emplace(v, 0);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\tif (i == g[u].size()) out_[u] = euler_map_.size();",
			"\t\t\t}",
			"\t\t}",
			"\t\t",
			"\t\tif (!use_lca) return;",
			"\t\tsize_type max_depth = *std::max_element(begin(heavy_depth_), end(heavy_depth_));",
			"\t\tsize_type lglg_n = 0;",
			"\t\twhile ((1 << lglg_n) < max_depth) ++lglg_n;",
			"\t\t",
			"\t\tpar_dblng_.assign(lglg_n + 1, std::vector<size_type>(af_size()));",
			"\t\tfor (size_type i = 0; i < af_size(); ++i) par_dblng_[0][i] = par_[head_[i]];",
			"\t\tfor (size_type i = 0; i < lglg_n; ++i) {",
			"\t\t\tfor (size_type j = 0; j < af_size(); ++j) {",
			"\t\t\t\tpar_dblng_[i + 1][j] = par_dblng_[i][heavy_map_[par_dblng_[i][j]]];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\tsize_type bf_size() const noexcept { return bf_n; }",
			"\tsize_type af_size() const noexcept { return head_.size(); }",
			"\t",
			"\tsize_type par(size_type v) const { assert(v < bf_size()); return par_[v]; }",
			"\tsize_type sub_size(size_type v) const { assert(v < bf_size()); return sub_size_[v]; }",
			"\tsize_type depth(size_type v) const { assert(v < bf_size()); return depth_[v]; }",
			"\t",
			"\tsize_type tree_id(size_type v) const { assert(v < bf_size()); return tree_id_[v]; }",
			"\tsize_type tree_cnt() const noexcept { return roots_.size(); }",
			"\tconst std::vector<size_type> & trees() const noexcept { return roots_; }",
			"\t",
			"\tsize_type heavy_map(size_type v) const { assert(v < bf_size()); return heavy_map_[v]; }",
			"\tsize_type head(size_type k) const { assert(k < af_size()); return head_[k]; }",
			"\tsize_type heavy_size(size_type k) const { assert(k < af_size()); return heavy_size_[k]; }",
			"\tsize_type heavy_depth(size_type k) const { assert(k < af_size()); return heavy_depth_[k]; }",
			"\t",
			"\tsize_type in(size_type v) const { assert(v < bf_size()); return in_[v]; }",
			"\tsize_type out(size_type v) const { assert(v < bf_size()); return out_[v]; }",
			"\tsize_type euler_map(size_type k) const { assert(k < bf_size()); return euler_map_[k]; }",
			"\t",
			"\tconst std::vector<std::vector<size_type>> & par_dblng() const {",
			"\t\tassert(!par_dblng_.empty());",
			"\t\treturn par_dblng_;",
			"\t}",
			"\t",
			"\tstd::pair<size_type, size_type> get_lca_path(size_type x, size_type y) const {",
			"\t\tassert(!par_dblng_.empty());",
			"\t\tassert(x < bf_size());",
			"\t\tassert(y < bf_size());",
			"\t\tassert(tree_id_[x] == tree_id_[y]);",
			"\t\tif (heavy_map_[x] == heavy_map_[y]) return {x, y};",
			"\t\t",
			"\t\tbool isswap = heavy_depth_[heavy_map_[x]] < heavy_depth_[heavy_map_[y]];",
			"\t\tif (isswap) std::swap(x, y);",
			"\t\t",
			"\t\tconst size_type diff = heavy_depth_[heavy_map_[x]] - heavy_depth_[heavy_map_[y]];",
			"\t\tfor (size_type i = par_dblng_.size(); i > 0; --i) {",
			"\t\t\tif (diff >> (i - 1) & 1) x = par_dblng_[i - 1][heavy_map_[x]];",
			"\t\t}",
			"\t\tif (heavy_map_[x] == heavy_map_[y]) return isswap ? std::make_pair(y, x) : std::make_pair(x, y);",
			"\t\t",
			"\t\tfor (size_type i = par_dblng_.size(); i > 0; --i) {",
			"\t\t\tconst size_type p1 = par_dblng_[i - 1][heavy_map_[x]], p2 = par_dblng_[i - 1][heavy_map_[y]];",
			"\t\t\tif (heavy_map_[p1] != heavy_map_[p2]) x = p1, y = p2;",
			"\t\t}",
			"\t\tx = par_dblng_[0][heavy_map_[x]];",
			"\t\ty = par_dblng_[0][heavy_map_[y]];",
			"\t\treturn isswap ? std::make_pair(y, x) : std::make_pair(x, y);",
			"\t}",
			"\t",
			"\tsize_type get_lca(size_type x, size_type y) {",
			"\t\tassert(!par_dblng_.empty());",
			"\t\tassert(x < bf_size());",
			"\t\tassert(y < bf_size());",
			"\t\tstd::pair<size_type, size_type> res = get_lca_path(x, y);",
			"\t\treturn in_[res.first] < in_[res.second] ? res.first : res.second;",
			"\t}",
			"};\n",
		],
		"description": [
			"重軽分解",
			"https://tkmst201.github.io/Library/GraphTheory/HeavyLightDecomposition.hpp",
			"2020/09/18",
		]
	},
	
	"HeavyLightDecomposition_Query": {
		"prefix": "HeavyLightDecomposition_Query",
		"body": [
			"template<class HLD, typename T, template<typename> class SEG>",
			"struct HeavyLightDecomposition_Query {",
			"\tusing value_type = T;",
			"\tusing const_reference = const value_type &;",
			"\tusing seg_type = SEG<value_type>;",
			"\tusing hld_type = HLD;",
			"\tusing size_type = std::uint_fast32_t;",
			"\tusing Graph = typename hld_type::Graph;",
			"\tusing F = std::function<value_type(const_reference, const_reference)>;",
			"\t",
			"private:",
			"\tvalue_type id_elem;",
			"\tF f;",
			"\thld_type hld;",
			"\tseg_type seg, rseg;",
			"\tbool value_on_vertex;",
			"\t",
			"public:",
			"\tHeavyLightDecomposition_Query(const Graph & g, const value_type & id_elem, const F & f, bool value_on_vertex)",
			"\t\t: HeavyLightDecomposition_Query(g, g.size(), id_elem, f, value_on_vertex) {}",
			"\t",
			"\tHeavyLightDecomposition_Query(const Graph & g, size_type root, const value_type & id_elem, const F & f, bool value_on_vertex)",
			"\t\t: id_elem(id_elem), f(f), hld(g, root, false), value_on_vertex(value_on_vertex) {",
			"\t\tseg = seg_type{ hld.bf_size(), id_elem, f };",
			"\t\trseg = seg_type{ hld.bf_size(), id_elem, f };",
			"\t}",
			"\t",
			"\ttemplate<typename U>",
			"\tHeavyLightDecomposition_Query(const Graph & g, const std::vector<U> & v, const value_type & id_elem, const F & f)",
			"\t\t: HeavyLightDecomposition_Query(g, g.size(), v, id_elem, f) {}",
			"\t",
			"\ttemplate<typename U>",
			"\tHeavyLightDecomposition_Query(const Graph & g, size_type root, const std::vector<U> & v, const value_type & id_elem, const F & f)",
			"\t\t: id_elem(id_elem), f(f), hld(g, root, false), value_on_vertex(true) {",
			"\t\tstd::vector<value_type> init(hld.bf_size());",
			"\t\tfor (size_type i = 0; i < hld.bf_size(); ++i) init[i] = v[hld.euler_map(i)];",
			"\t\tseg = seg_type{ init, id_elem, f };",
			"\t\t",
			"\t\tfor (size_type i = 0; i < hld.af_size(); ++i) {",
			"\t\t\tconst size_type fidx = hld.in(hld.head(i));",
			"\t\t\tstd::reverse(begin(init) + fidx, begin(init) + fidx + hld.heavy_size(i));",
			"\t\t}",
			"\t\trseg = seg_type{ init, id_elem, f };",
			"\t}",
			"\t",
			"\tconst hld_type & get_hld() const {",
			"\t\treturn hld;",
			"\t}",
			"\t",
			"\tvoid set(size_type v, const_reference x) {",
			"\t\tassert(value_on_vertex);",
			"\t\tassert(v < hld.bf_size());",
			"\t\tset_(v, x);",
			"\t}",
			"\t",
			"\tvalue_type get(size_type v) const {",
			"\t\tassert(value_on_vertex);",
			"\t\tassert(v < hld.bf_size());",
			"\t\treturn get_(v);",
			"\t}",
			"\t",
			"\tvoid set(size_type u, size_type v, const_reference x) {",
			"\t\tassert(!value_on_vertex);",
			"\t\tassert(u < hld.bf_size());",
			"\t\tassert(v < hld.bf_size());",
			"\t\tassert(hld.par(u) == v || hld.par(v) == u);",
			"\t\tset_(hld.par(u) == v ? u : v, x);",
			"\t}",
			"\t",
			"\tvalue_type get(size_type u, size_type v) const {",
			"\t\tassert(!value_on_vertex);",
			"\t\tassert(u < hld.bf_size());",
			"\t\tassert(v < hld.bf_size());",
			"\t\tassert(hld.par(u) == v || hld.par(v) == u);",
			"\t\treturn get_(hld.par(u) == v ? u : v);",
			"\t}",
			"\t",
			"private:",
			"\tvoid set_(size_type v, const_reference x) {",
			"\t\tseg.set(hld.in(v), x);",
			"\t\trseg.set(reverse_idx(v), x);",
			"\t}",
			"\t",
			"\tvalue_type get_(size_type v) const {",
			"\t\treturn seg.get(hld.in(v));",
			"\t}",
			"\t",
			"public:",
			"\tvalue_type fold(size_type u, size_type v) const {",
			"\t\tassert(u < hld.bf_size());",
			"\t\tassert(v < hld.bf_size());",
			"\t\tassert(hld.tree_id(u) == hld.tree_id(v));",
			"\t\tvalue_type lv = id_elem, rv = id_elem;",
			"\t\t",
			"\t\twhile (hld.heavy_map(u) != hld.heavy_map(v)) {",
			"\t\t\tif (hld.heavy_depth(hld.heavy_map(u)) >= hld.heavy_depth(hld.heavy_map(v))) {",
			"\t\t\t\tconst size_type head = hld.head(hld.heavy_map(u));",
			"\t\t\t\tlv = f(lv, rseg.fold(reverse_idx(u), reverse_idx(head) + 1));",
			"\t\t\t\tu = hld.par(head);",
			"\t\t\t}",
			"\t\t\tif (hld.heavy_map(u) == hld.heavy_map(v)) break;",
			"\t\t\tif (hld.heavy_depth(hld.heavy_map(u)) <= hld.heavy_depth(hld.heavy_map(v))) {",
			"\t\t\t\tconst size_type head = hld.head(hld.heavy_map(v));",
			"\t\t\t\trv = f(seg.fold(hld.in(head), hld.in(v) + 1), rv);",
			"\t\t\t\tv = hld.par(head);",
			"\t\t\t}",
			"\t\t}",
			"\t\t",
			"\t\tconst size_type id = hld.heavy_map(u);",
			"\t\tif (hld.in(u) < hld.in(v)) rv = f(seg.fold(hld.in(u) + !value_on_vertex, hld.in(v) + 1), rv);",
			"\t\telse lv = f(lv, rseg.fold(reverse_idx(u), reverse_idx(v) + value_on_vertex));",
			"\t\treturn f(lv, rv);",
			"\t}",
			"\t",
			"\tvalue_type subtree_sum(size_type v) const {",
			"\t\treturn seg.fold(hld.in(v), hld.out(v));",
			"\t}",
			"\t",
			"private:",
			"\tsize_type reverse_idx(size_type v) const {",
			"\t\tconst size_type id = hld.heavy_map(v);",
			"\t\treturn (hld.in(hld.head(id)) << 1) + hld.heavy_size(id) - hld.in(v) - 1;",
			"\t}",
			"};\n",
		],
		"description": [
			"重軽分解を用いた (パス or 部分木) クエリ処理",
			"https://tkmst201.github.io/Library/GraphTheory/HeavyLightDecomposition_Query.hpp",
			"2020/09/18",
		]
	},
	
	"StronglyConnectedComponents": {
		"prefix": "StronglyConnectedComponents",
		"body": [
			"struct StronglyConnectedComponents {",
			"\tusing size_type = std::size_t;",
			"\t",
			"private:",
			"\tstd::vector<std::vector<size_type>> g, rg;",
			"\tstd::vector<size_type> rank; // [i] := 頂点 i が属する強連結成分のトポロジカル順序",
			"\tstd::vector<std::vector<size_type>> idx_map; // [i][j] := トポロジカル順序が i の強連結成分に属する j 番目の頂点の番号(昇順)",
			"\tbool isbuilt = false;",
			"\t",
			"public:",
			"\tStronglyConnectedComponents(size_type n) {",
			"\t\tg.resize(n);",
			"\t\trg.resize(n);",
			"\t}",
			"\t",
			"\tStronglyConnectedComponents(std::vector<std::vector<size_type>> g) : g(g) {",
			"\t\trg.resize(size());",
			"\t\tfor (size_type i = 0; i < size(); ++i) {",
			"\t\t\tfor (size_type j : g[i]) rg[j].emplace_back(i);",
			"\t\t}",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn g.size();",
			"\t}",
			"\t",
			"\tvoid add_edge(size_type u, size_type v) {",
			"\t\tassert(u < size());",
			"\t\tassert(v < size());",
			"\t\tg[u].emplace_back(v);",
			"\t\trg[v].emplace_back(u);",
			"\t\tisbuilt = false;",
			"\t}",
			"\t",
			"\tsize_type build(bool build_idx_map = true) {",
			"\t\tstd::vector<bool> visited;",
			"\t\tstd::vector<size_type> back_num; // [i] := 帰りがけ順が i である頂点",
			"\t\t",
			"\t\tauto dfs = [&](auto &&self, size_type u) -> void {",
			"\t\t\tvisited[u] = true;",
			"\t\t\tfor (size_type v : g[u]) if (!visited[v]) self(self, v);",
			"\t\t\tsize_type c = back_num.size();",
			"\t\t\tback_num.emplace_back(u);",
			"\t\t};",
			"\t\t",
			"\t\tvisited.assign(size(), false);",
			"\t\tback_num.reserve(size());",
			"\t\tfor (size_type i = 0; i < size(); ++i) if (!visited[i]) dfs(dfs, i);",
			"\t\t",
			"\t\tsize_type c = 0;",
			"\t\tauto rdfs = [&](auto &&self, size_type u) -> void {",
			"\t\t\tvisited[u] = true;",
			"\t\t\trank[u] = c;",
			"\t\t\tfor (size_type v : rg[u]) if (!visited[v]) self(self, v);",
			"\t\t};",
			"\t\t",
			"\t\trank.resize(size());",
			"\t\tvisited.assign(size(), false);",
			"\t\tfor (size_type i = size(); i > 0; --i) {",
			"\t\t\tconst size_type u = back_num[i - 1];",
			"\t\t\tif (visited[u]) continue;",
			"\t\t\trdfs(rdfs, u);",
			"\t\t\t++c;",
			"\t\t}",
			"\t\t",
			"\t\tif (build_idx_map) {",
			"\t\t\tidx_map.assign(c, {});",
			"\t\t\tfor (size_type i = 0; i < size(); ++i) idx_map[rank[i]].emplace_back(i);",
			"\t\t}",
			"\t\tisbuilt = true;",
			"\t\treturn c;",
			"\t}",
			"\t",
			"\tsize_type get_rank(size_type i) const {",
			"\t\tassert(isbuilt);",
			"\t\tassert(i < size());",
			"\t\treturn rank[i];",
			"\t}",
			"\t",
			"\tconst std::vector<size_type> & get_map(size_type i) const {",
			"\t\tassert(isbuilt);",
			"\t\tassert(i < idx_map.size());",
			"\t\treturn idx_map[i];",
			"\t}",
			"\t",
			"\tstd::vector<std::vector<size_type>> get_graph() const {",
			"\t\tassert(isbuilt);",
			"\t\tstd::vector<std::vector<size_type>> res(idx_map.size());",
			"\t\tfor (size_type i = 0; i < idx_map.size(); ++i) {",
			"\t\t\tfor (size_type j : idx_map[i]) {",
			"\t\t\t\tfor (size_type v : g[j]) res[i].emplace_back(get_rank(v));",
			"\t\t\t}",
			"\t\t\tstd::sort(begin(res[i]), end(res[i]));",
			"\t\t\tres[i].erase(unique(begin(res[i]), end(res[i])), end(res[i]));",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};\n",
		],
		"description": [
			"強連結成分分解",
			"https://tkmst201.github.io/Library/GraphTheory/StronglyConnectedComponents.hpp",
			"2020/10/30",
		]
	},
	
	
	/* Mathematics */
	"ModInt": {
		"prefix":"ModInt",
		"body": [
			"template<int M>",
			"struct ModInt {",
			"public:",
			"\tusing value_type = long long;",
			"\t",
			"\tModInt(value_type val = 0) : val(val < 0 ? (M - (-val % M)) % M : val % M) {}",
			"\t",
			"\texplicit operator bool() const noexcept { return val; }",
			"\tbool operator ==(const ModInt & rhs) const noexcept { return val == rhs.val; }",
			"\tbool operator !=(const ModInt & rhs) const noexcept { return !(*this == rhs); }",
			"\tModInt operator +() const noexcept { return ModInt(*this); }",
			"\tModInt operator -() const noexcept { return ModInt(0) -= *this; }",
			"\tModInt operator +(const ModInt & rhs) const noexcept { return ModInt(*this) += rhs; }",
			"\tModInt operator -(const ModInt & rhs) const noexcept { return ModInt(*this) -= rhs; }",
			"\tModInt operator *(const ModInt & rhs) const noexcept { return ModInt(*this) *= rhs; }",
			"\tModInt operator /(const ModInt & rhs) const noexcept { return ModInt(*this) /= rhs; }",
			"\t",
			"\tModInt & operator +=(const ModInt & rhs) noexcept {",
			"\t\tval += rhs.val;",
			"\t\tif (val >= M) val -= M;",
			"\t\treturn *this;",
			"\t}",
			"\tModInt & operator -=(const ModInt & rhs) noexcept {",
			"\t\tif (val < rhs.val) val += M;",
			"\t\tval -= rhs.val;",
			"\t\treturn *this;",
			"\t}",
			"\tModInt & operator *=(const ModInt & rhs) noexcept {",
			"\t\tval = val * rhs.val % M;",
			"\t\treturn *this;",
			"\t}",
			"\tModInt & operator /=(const ModInt & rhs) noexcept {",
			"\t\t*this *= rhs.inverse();",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tModInt pow(value_type n) const {",
			"\t\tModInt res = 1, x = val;",
			"\t\tif (n < 0) { x = x.inverse(); n = -n; }",
			"\t\twhile (n) { if (n & 1) res *= x; x *= x; n >>= 1; }",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tModInt inverse() const {",
			"\t\tlong long a = val, a1 = 1, a2 = 0, b = M, b1 = 0, b2 = 1;",
			"\t\twhile (b > 0) {",
			"\t\t\tvalue_type q = a / b, r = a % b;",
			"\t\t\tvalue_type nb1 = a1 - q * b1, nb2 = a2 - q * b2;",
			"\t\t\ta = b; b = r;",
			"\t\t\ta1 = b1; b1 = nb1;",
			"\t\t\ta2 = b2; b2 = nb2;",
			"\t\t}",
			"\t\tassert(a == 1);",
			"\t\treturn a1;",
			"\t}",
			"\t",
			"\tconst value_type & get() const noexcept { return val; }",
			"\tstatic decltype(M) get_mod() noexcept { return M; }",
			"\t",
			"\tfriend std::ostream & operator <<(std::ostream & os, const ModInt & rhs) { return os << rhs.val; }",
			"\tfriend std::istream & operator >>(std::istream & is, ModInt & rhs) {",
			"\t\tvalue_type x;",
			"\t\tis >> x;",
			"\t\trhs = ModInt(x);",
			"\t\treturn is;",
			"\t}",
			"private:",
			"\tvalue_type val;",
			"};",
			"using mint = ModInt<MOD>;\n",
		],
		"description": [
			"ModInt",
			"https://tkmst201.github.io/Library/Mathematics/ModInt.hpp",
			"2020/02/26"
		]
	},
	
	"RuntimeModInt": {
		"prefix": "RuntimeModInt",
		"body": [
			"struct RuntimeModInt {",
			"public:",
			"\tusing value_type = long long;",
			"\t",
			"\tRuntimeModInt(value_type val = 0) : val(val < 0 ? (mod() - (-val % mod())) % mod() : val % mod()) {}",
			"\t",
			"\texplicit operator bool() const noexcept { return val; }",
			"\tbool operator ==(const RuntimeModInt & rhs) const noexcept { return val == rhs.val; }",
			"\tbool operator !=(const RuntimeModInt & rhs) const noexcept { return !(*this == rhs); }",
			"\tRuntimeModInt operator +() const noexcept { return RuntimeModInt(*this); }",
			"\tRuntimeModInt operator -() const noexcept { return RuntimeModInt(0) -= *this; }",
			"\tRuntimeModInt operator +(const RuntimeModInt & rhs) const noexcept { return RuntimeModInt(*this) += rhs; }",
			"\tRuntimeModInt operator -(const RuntimeModInt & rhs) const noexcept { return RuntimeModInt(*this) -= rhs; }",
			"\tRuntimeModInt operator *(const RuntimeModInt & rhs) const noexcept { return RuntimeModInt(*this) *= rhs; }",
			"\tRuntimeModInt operator /(const RuntimeModInt & rhs) const noexcept { return RuntimeModInt(*this) /= rhs; }",
			"\t",
			"\tRuntimeModInt & operator +=(const RuntimeModInt & rhs) noexcept {",
			"\t\tval += rhs.val;",
			"\t\tif (val >= mod()) val -= mod();",
			"\t\treturn *this;",
			"\t}",
			"\tRuntimeModInt & operator -=(const RuntimeModInt & rhs) noexcept {",
			"\t\tif (val < rhs.val) val += mod();",
			"\t\tval -= rhs.val;",
			"\t\treturn *this;",
			"\t}",
			"\tRuntimeModInt & operator *=(const RuntimeModInt & rhs) noexcept {",
			"\t\tval = val * rhs.val % mod();",
			"\t\treturn *this;",
			"\t}",
			"\tRuntimeModInt & operator /=(const RuntimeModInt & rhs) noexcept {",
			"\t\t*this *= rhs.inverse();",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tRuntimeModInt pow(value_type n) const {",
			"\t\tRuntimeModInt res = 1, x = val;",
			"\t\tif (n < 0) { x = x.inverse(); n = -n; }",
			"\t\twhile (n) { if (n & 1) res *= x; x *= x; n >>= 1; }",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tRuntimeModInt inverse() const {",
			"\t\tlong long a = val, a1 = 1, a2 = 0, b = mod(), b1 = 0, b2 = 1;",
			"\t\twhile (b > 0) {",
			"\t\t\tvalue_type q = a / b, r = a % b;",
			"\t\t\tvalue_type nb1 = a1 - q * b1, nb2 = a2 - q * b2;",
			"\t\t\ta = b; b = r;",
			"\t\t\ta1 = b1; b1 = nb1;",
			"\t\t\ta2 = b2; b2 = nb2;",
			"\t\t}",
			"\t\tassert(a == 1);",
			"\t\treturn a1;",
			"\t}",
			"\t",
			"\tconst value_type & get() const noexcept { return val; }",
			"\tstatic void set_mod(int M) noexcept { mod() = M; }",
			"\tstatic int get_mod() noexcept { return mod(); }",
			"\t",
			"\tfriend std::ostream & operator <<(std::ostream & os, const RuntimeModInt & rhs) { return os << rhs.val; }",
			"\tfriend std::istream & operator >>(std::istream & is, RuntimeModInt & rhs) {",
			"\t\tvalue_type x;",
			"\t\tis >> x;",
			"\t\trhs = RuntimeModInt(x);",
			"\t\treturn is;",
			"\t}",
			"private:",
			"\tvalue_type val;",
			"\t",
			"\tstatic int & mod() {",
			"\t\tstatic int M = 2;",
			"\t\treturn M;",
			"\t}",
			"};",
			"using mint = RuntimeModInt;\n",
		],
		"description": [
			"実行時 mod 指定 ModInt",
			"https://tkmst201.github.io/Library/Mathematics/RuntimeModInt.hpp",
			"2020/02/26"
		]
	},
	
	"Combination": {
		"prefix":"Combination",
		"body": [
			"template<typename T>",
			"struct Combination {",
			"public:",
			"\tusing size_type = std::size_t;",
			"\t",
			"\tCombination(size_type sz = 1) : _fact(1, 1), _finv(1, 1), _inv(1, 1) { build(sz); }",
			"\t",
			"\tT fact(size_type k) { if (k >= T::get_mod()) return 0; build(k); return _fact[k]; }",
			"\tT finv(size_type k) { assert(k < T::get_mod()); build(k); return _finv[k]; }",
			"\tT inv(size_type k) { assert(k > 0 && k < T::get_mod()); build(k); return _inv[k]; }",
			"\t",
			"\tT operator ()(int n, int r) { return c(n, r); }",
			"\tT c(int n, int r) {",
			"\t\tif (r < 0 || n < r) return 0;",
			"\t\treturn fact(n) * finv(r) * finv(n - r);",
			"\t}",
			"\t",
			"private:",
			"\tstd::vector<T> _fact, _finv, _inv;",
			"\tstatic constexpr size_type MAX_LIMIT = 50000000;",
			"\t",
			"\tvoid build(size_type k) {",
			"\t\tif (_fact.size() > k) return;",
			"\t\tassert(k < MAX_LIMIT);",
			"\t\tsize_type sz = std::min({MAX_LIMIT, static_cast<size_type>(T::get_mod()), std::max(_fact.size() * 2, k + 1)});",
			"\t\tsize_type presz = _fact.size();",
			"\t\t_fact.resize(sz);",
			"\t\t_finv.resize(sz);",
			"\t\t_inv.resize(sz);",
			"\t\t",
			"\t\tfor (size_type i = presz; i < sz; ++i) _fact[i] = _fact[i - 1] * i;",
			"\t\t_finv[sz - 1] = T(_fact[sz - 1]).inverse();",
			"\t\tfor (size_type i = sz - 1; i > presz; --i) {",
			"\t\t\t_finv[i - 1] = _finv[i] * i;",
			"\t\t\t_inv[i] = _fact[i - 1] * _finv[i];",
			"\t\t}",
			"\t\t_inv[presz] = _fact[presz - 1] * _finv[presz];",
			"\t}",
			"};",
			"using Comb = Combination<mint>;",
			"Comb comb;\n",
		],
		"description": [
			"組み合わせ, 階乗, 階乗逆元, 逆元 (動的構築)",
			"https://tkmst201.github.io/Library/Mathematics/Combination.hpp",
			"2020/02/12",
		]
	},
	
	"Combination(AtCoder)": {
		"prefix":"Combination_atcoder",
		"body": [
			"template<typename T>",
			"struct Combination {",
			"public:",
			"\tusing size_type = std::size_t;",
			"\t",
			"\tCombination(size_type sz = 1) : _fact(1, 1), _finv(1, 1), _inv(1, 1) { build(sz); }",
			"\t",
			"\tT fact(size_type k) { if (k >= T::mod()) return 0; build(k); return _fact[k]; }",
			"\tT finv(size_type k) { assert(k < T::mod()); build(k); return _finv[k]; }",
			"\tT inv(size_type k) { assert(k > 0 && k < T::mod()); build(k); return _inv[k]; }",
			"\t",
			"\tT operator ()(int n, int r) { return c(n, r); }",
			"\tT c(int n, int r) {",
			"\t\tif (r < 0 || n < r) return 0;",
			"\t\treturn fact(n) * finv(r) * finv(n - r);",
			"\t}",
			"\t",
			"private:",
			"\tstd::vector<T> _fact, _finv, _inv;",
			"\tstatic constexpr size_type MAX_LIMIT = 50000000;",
			"\t",
			"\tvoid build(size_type k) {",
			"\t\tif (_fact.size() > k) return;",
			"\t\tassert(k < MAX_LIMIT);",
			"\t\tsize_type sz = std::min({MAX_LIMIT, static_cast<size_type>(T::mod()), std::max(_fact.size() * 2, k + 1)});",
			"\t\tsize_type presz = _fact.size();",
			"\t\t_fact.resize(sz);",
			"\t\t_finv.resize(sz);",
			"\t\t_inv.resize(sz);",
			"\t\t",
			"\t\tfor (size_type i = presz; i < sz; ++i) _fact[i] = _fact[i - 1] * i;",
			"\t\t_finv[sz - 1] = T(1) / T(_fact[sz - 1]);",
			"\t\tfor (size_type i = sz - 1; i > presz; --i) {",
			"\t\t\t_finv[i - 1] = _finv[i] * i;",
			"\t\t\t_inv[i] = _fact[i - 1] * _finv[i];",
			"\t\t}",
			"\t\t_inv[presz] = _fact[presz - 1] * _finv[presz];",
			"\t}",
			"};",
			"using Comb = Combination<mint>;",
			"Comb comb;\n",
		],
		"description": [
			"組み合わせ, 階乗, 階乗逆元, 逆元 (動的構築) ac-library ver.",
			"https://tkmst201.github.io/Library/Mathematics/Combination.hpp",
			"2020/02/12",
		]
	},
	
	"MathUtility": {
		"prefix": "MathUtility",
		"body": [
			"namespace tk {",
			"template<typename T>",
			"T gcd(T a, T b) {",
			"\tassert(a >= 0);",
			"\tassert(b >= 0);",
			"\twhile (b != 0) {",
			"\t\tT t = a % b;",
			"\t\ta = b; b = t;",
			"\t}",
			"\treturn a;",
			"}",
			"",
			"template<typename T>",
			"T lcm(T a, T b) {",
			"\tassert(a >= 0);",
			"\tassert(b >= 0);",
			"\tif (a == 0 || b == 0) return 0;",
			"\treturn a / gcd(a, b) * b;",
			"}",
			"",
			"template<typename T>",
			"T ext_gcd(const T & a, T & x, const T & b, T & y) {",
			"\tassert(a > 0);",
			"\tassert(b > 0);",
			"\tT a0 = a, a1 = 1, a2 = 0, b0 = b, b1 = 0, b2 = 1;",
			"\twhile (b0 > 0) {",
			"\t\tT q = a0 / b0, r = a0 % b0;",
			"\t\tT nb1 = a1 - q * b1, nb2 = a2 - q * b2;",
			"\t\ta0 = b0; b0 = r;",
			"\t\ta1 = b1; b1 = nb1;",
			"\t\ta2 = b2; b2 = nb2;",
			"\t}",
			"\tx = a1;",
			"\ty = a2;",
			"\treturn a0;",
			"}",
			"",
			"template<typename T>",
			"T mod_pow(T x, T n, const T & mod) {",
			"\tassert(mod > 0);",
			"\tassert(n >= 0);",
			"\tx = (x % mod + mod) % mod;",
			"\tT res = 1 % mod;",
			"\twhile (n > 0) {",
			"\t\tif (n & 1) res = res * x % mod;",
			"\t\tx = x * x % mod;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"template<typename T>",
			"T mod_inv(const T & x, const T & mod) {",
			"\tassert(x > 0);",
			"\tassert(mod > 0);",
			"\tT a, b;",
			"\tT g = ext_gcd(x, a, mod, b);",
			"\tassert(g == 1);",
			"\treturn (a % mod + mod) % mod;",
			"}",
			"",
			"template<typename T>",
			"std::pair<T, T> chinese_remainder(T b1, T m1, T b2, T m2) {",
			"\tassert(m1 > 0);",
			"\tassert(m2 > 0);",
			"\tif (m1 < m2) { std::swap(b1, b2); std::swap(m1, m2); }",
			"\tb1 = (b1 % m1 + m1) % m1;",
			"\tb2 = (b2 % m2 + m2) % m2;",
			"\t",
			"\tT x, y;",
			"\tT g = ext_gcd(m1, x, m2, y);",
			"\tconst T pm2 = m2 / g;",
			"\tx = (x % pm2 + pm2) % pm2;",
			"\t",
			"\tif ((b2 - b1) % g != 0) return {0, 0};",
			"\tconst T t = ((b2 - b1) / g % pm2 + pm2) % pm2 * x % pm2;",
			"\treturn {b1 + t * m1, m1 * pm2};",
			"}",
			"} // namespace tk\n",
		],
		"description": [
			"便利数学関数詰め合わせ (gcd, lcm, ext_gcd, mod_pow, mod_inv, chinese_remainder)",
			"https://tkmst201.github.io/Library/Mathematics/MathUtility.hpp",
			"2020/09/21"
		]
	},
	
	"enumerate_primes": {
		"prefix": "enumerate_primes",
		"body": [
			"namespace tk {",
			"std::vector<std::uint32_t> enumerate_primes(std::uint32_t n) {",
			"\tif (n < 2) return {};",
			"\tusing byte = std::uint8_t;",
			"\tusing uint32 = std::uint32_t;",
			"\t",
			"\tconstexpr byte m[8] = {1, 7, 11, 13, 17, 19, 23, 29};",
			"\tconstexpr byte diff[8] = {6, 4, 2, 4, 2, 4, 6, 2}; // [i] := m[i + 1] - m[i]",
			"\tconstexpr byte plus_byte[8][8] = {",
			"\t\t{0,0,0,0,0,0,0,1},{1,1,1,0,1,1,1,1},{2,2,0,2,0,2,2,1},{3,1,1,2,1,1,3,1},",
			"\t\t{3,3,1,2,1,3,3,1},{4,2,2,2,2,2,4,1},{5,3,1,4,1,3,5,1},{6,4,2,4,2,4,6,1},",
			"\t}; // [i][j] := floor(m_i m_{j+1} / 30) - floor(m_i m_j / 30)",
			"\tconstexpr byte bit_mask[8][8] = {",
			"\t\t{254,253,251,247,239,223,191,127},{253,223,239,254,127,247,251,191},",
			"\t\t{251,239,254,191,253,127,247,223},{247,254,191,223,251,253,127,239},",
			"\t\t{239,127,253,251,223,191,254,247},{223,247,127,253,191,254,239,251},",
			"\t\t{191,251,247,127,254,239,223,253},{127,191,223,239,247,251,253,254},",
			"\t}; // [i][j] := ((1<<8)-1) - (1 << to_m_idx(m[i]m[j] (mod. 30))) (mod. 8))",
			"\t",
			"\tauto pop_count = [](byte x) {",
			"\t\tbyte res = (x & 0x55) + (x >> 1 & 0x55);",
			"\t\tres = (res & 0x33) + (res >> 2 & 0x33);",
			"\t\tres = (res + (res >> 4)) & 0xf;",
			"\t\treturn res;",
			"\t};",
			"\t",
			"\tauto sqrt = [](uint32 n) {",
			"\t\tuint32 res = 0;",
			"\t\tfor (uint32 i = sizeof(n) << 2; i > 0; --i) {",
			"\t\t\tuint32 x = res + (1u << (i - 1));",
			"\t\t\tif (x * x <= n) res |= 1u << (i - 1);",
			"\t\t}",
			"\t\treturn res;",
			"\t};",
			"\t",
			"\tbyte b_idx[129]; // [1 << i] = i",
			"\tfor (uint32 i = 0; i < 8; ++i) b_idx[1 << i] = i;",
			"\t",
			"\tauto get_prime_pos = [&](uint32 n) {",
			"\t\tuint32 s = sqrt(n); // floor(sqrt(n))",
			"\t\tconst uint32 s30 = s / 30 + (s % 30 != 0);",
			"\t\tconst uint32 n30 = n / 30 + (n % 30 != 0);",
			"\t\t",
			"\t\tstd::vector<byte> isprime(n30, 255);",
			"\t\tisprime[0] = 254;",
			"\t\tfor (uint32 i = 0; i < s30; ++i) {",
			"\t\t\tfor (byte j = isprime[i]; j; j &= j - 1) {",
			"\t\t\t\tconst byte mi = b_idx[j & -j];",
			"\t\t\t\tbyte k = mi;",
			"\t\t\t\tfor (uint32 b = (30*i + 2*m[mi])*i + m[mi]*m[mi]/30; b < n30; b += i*diff[k] + plus_byte[mi][k], k = (k + 1) & 7)",
			"\t\t\t\t\tisprime[b] &= bit_mask[mi][k];",
			"\t\t\t}",
			"\t\t}",
			"\t\t",
			"\t\tfor (uint32 i = 8; i > 0; --i) {",
			"\t\t\tif ((n30 - 1) * 30 + m[i - 1] <= n) break;",
			"\t\t\tisprime.back() &= ~(1 << (i - 1));",
			"\t\t}",
			"\t\t",
			"\t\tuint32 cnt = 0;",
			"\t\tstd::vector<uint32> prime_pos; // {byte} << 3 | {bit}",
			"\t\tfor (uint32 i = 0; i < n30; ++i) {",
			"\t\t\tfor (uint32 j = isprime[i]; j; j &= j - 1) {",
			"\t\t\t\tprime_pos.emplace_back(i << 3 | b_idx[j & -j]);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn prime_pos;",
			"\t};",
			"\t",
			"\tauto prime_pos = get_prime_pos(sqrt(n));",
			"\tconstexpr uint32 segment = 1 << 18;",
			"\tstd::vector<uint32> pos;",
			"\tpos.reserve(prime_pos.size());",
			"\tfor (uint32 i = 0; i < prime_pos.size(); ++i) {",
			"\t\tconst uint32 pb = prime_pos[i] >> 3;",
			"\t\tconst byte mi = prime_pos[i] & 7;",
			"\t\tpos.emplace_back(((30*pb + 2*m[mi])*pb + m[mi]*m[mi]/30) << 3 | mi);",
			"\t}",
			"\t",
			"\t",
			"\tconst uint32 n30 = n / 30 + (n % 30 != 0);",
			"\t",
			"\tstd::vector<uint32> primes;",
			"\tif (2 <= n) primes.emplace_back(2);",
			"\tif (3 <= n) primes.emplace_back(3);",
			"\tif (5 <= n) primes.emplace_back(5);",
			"\t",
			"\tstd::vector<uint32> isprime;",
			"\tfor (uint32 l = 0; l < n30; l += segment) {",
			"\t\tconst uint32 d = std::min(segment, n30 - l);",
			"\t\tconst uint32 r = l + d;",
			"\t\t",
			"\t\tisprime.assign(d, 255);",
			"\t\tif (l == 0) isprime[0] = 254;",
			"\t\t",
			"\t\tfor (uint32 i = 0; i < prime_pos.size(); ++i) {",
			"\t\t\tconst uint32 pb = prime_pos[i] >> 3;",
			"\t\t\tconst byte mi = prime_pos[i] & 7;",
			"\t\t\tuint32 b = pos[i] >> 3;",
			"\t\t\tbyte k = pos[i] & 7;",
			"\t\t\twhile (b < d) {",
			"\t\t\t\tisprime[b] &= bit_mask[mi][k];",
			"\t\t\t\tb += pb*diff[k] + plus_byte[mi][k];",
			"\t\t\t\tk = (k + 1) & 7;",
			"\t\t\t}",
			"\t\t\tpos[i] = (b - d) << 3 | k;",
			"\t\t}",
			"\t\t",
			"\t\tfor (uint32 i = 8; i > 0; --i) {",
			"\t\t\tif ((r - 1) * 30 + m[i - 1] <= n) break;",
			"\t\t\tisprime.back() &= ~(1 << (i - 1));",
			"\t\t}",
			"\t\t",
			"\t\tfor (uint32 i = 0; i < d; ++i) {",
			"\t\t\tfor (uint32 j = isprime[i]; j; j &= j - 1) primes.emplace_back((l + i) * 30 + m[b_idx[j & -j]]);",
			"\t\t}",
			"\t}",
			"\treturn primes;",
			"}",
			"} // namespace tk\n",
		],
		"description": [
			"素数列挙(高速化されたエラトステネスの篩)",
			"https://tkmst201.github.io/Library/Mathematics/PrimeNumber/enumerate_primes.hpp",
			"2020/09/08"
		]
	},
	
	"Matrix": {
		"prefix": "Matrix",
		"body": [
			"template<typename T>",
			"struct Matrix {",
			"public:",
			"\tusing value_type = T;",
			"\tusing size_type = std::size_t;",
			"\t",
			"\tMatrix() {}",
			"\tMatrix(size_type h, size_type w, const value_type & x = 0) : h(h), w(w), val(h, std::vector<value_type>(w, x)) {",
			"\t\tassert(h > 0 && w > 0);",
			"\t}",
			"\tMatrix(std::vector<std::vector<value_type>> val) : h(val.size()), w(val.size() ? val[0].size() : 0), val(val) {",
			"\t\tassert(h > 0 && w > 0);",
			"\t\tfor (size_type i = 1; i < h; ++i) assert(val[i].size() == w);",
			"\t}",
			"\tMatrix(std::initializer_list<std::vector<value_type>> init) : val(init.begin(), init.end()) {",
			"\t\th = val.size();",
			"\t\tw = val.size() ? val[0].size() : 0;",
			"\t\tassert(h > 0 && w > 0);",
			"\t\tfor (size_type i = 1; i < h; ++i) assert(val[i].size() == w);",
			"\t}",
			"\t",
			"\tstd::vector<value_type> & operator [](size_type i) noexcept { return val[i]; }",
			"\tconst std::vector<value_type> & operator [](size_type i) const noexcept { return val[i]; };",
			"\tvalue_type & operator ()(size_type i, size_type j) noexcept { return val[i][j]; };",
			"\tconst value_type & operator ()(size_type i, size_type j) const noexcept { return val[i][j]; }",
			"\tvalue_type & at(size_type i, size_type j) {",
			"\t\tassert(i < h && j < w);",
			"\t\treturn val[i][j];",
			"\t}",
			"\tconst value_type & at(size_type i, size_type j) const {",
			"\t\tassert(i < h & j < w);",
			"\t\treturn val[i][j];",
			"\t}",
			"\t",
			"\tbool empty() const { return !(h || w); }",
			"\tstd::pair<size_type, size_type> type() const { return std::make_pair(h, w); }",
			"\tbool match_type(const Matrix & rhs) const noexcept { return h == rhs.h && w == rhs.w; }",
			"\tbool is_square() const { return h == w; }",
			"\tconst std::vector<std::vector<value_type>> & get() const noexcept { return val; }",
			"\t",
			"\tbool operator ==(const Matrix & rhs) const noexcept { return match_type(rhs) && val == rhs.val; }",
			"\tbool operator !=(const Matrix & rhs) const noexcept { return !(*this == rhs); }",
			"\tMatrix operator +() const { return Matrix(*this); }",
			"\tMatrix operator -() const { return Matrix(h, w) - Matrix(*this); }",
			"\tMatrix operator +(const Matrix & rhs) const { return Matrix(*this) += rhs; }",
			"\tMatrix operator -(const Matrix & rhs) const { return Matrix(*this) -= rhs; }",
			"\tMatrix operator *(const Matrix & rhs) const {",
			"\t\tassert(w == rhs.h);",
			"\t\tMatrix res(h, rhs.w);",
			"\t\tfor (size_type i = 0; i < h; ++i) for (size_type j = 0; j < rhs.w; ++j) for (size_type k = 0; k < w; ++k)",
			"\t\t\tres.val[i][j] += val[i][k] * rhs.val[k][j];",
			"\t\treturn res;",
			"\t}",
			"\tMatrix operator /(const Matrix & rhs) const { return Matrix(*this) /= rhs; }",
			"\tfriend Matrix operator *(const value_type & lhs, const Matrix & rhs) {",
			"\t\tMatrix res(rhs.val);",
			"\t\tfor (size_type i = 0; i < res.h; ++i) for (size_type j = 0; j < res.w; ++j)",
			"\t\t\tres.val[i][j] = lhs * res.val[i][j];",
			"\t\treturn res;",
			"\t}",
			"\tMatrix operator *(const value_type & rhs) const {",
			"\t\tMatrix res(val);",
			"\t\tfor (size_type i = 0; i < h; ++i) for (size_type j = 0; j < w; ++j)",
			"\t\t\tres.val[i][j] *= rhs;",
			"\t\treturn res;",
			"\t}",
			"\tMatrix operator /(const value_type & rhs) const {",
			"\t\tMatrix res(val);",
			"\t\tfor (size_type i = 0; i < h; ++i) for (size_type j = 0; j < w; ++j)",
			"\t\t\tres.val[i][j] /= rhs;",
			"\t\treturn res;",
			"\t}",
			"\tMatrix & operator +=(const Matrix & rhs) {",
			"\t\tassert(match_type(rhs));",
			"\t\tfor (size_type i = 0; i < h; ++i) for (size_type j = 0; j < w; ++j)",
			"\t\t\tval[i][j] += rhs.val[i][j];",
			"\t\treturn *this;",
			"\t}",
			"\tMatrix & operator -=(const Matrix & rhs) {",
			"\t\tassert(match_type(rhs));",
			"\t\tfor (size_type i = 0; i < h; ++i) for(size_type j = 0; j < w; ++j)",
			"\t\t\tval[i][j] -= rhs.val[i][j];",
			"\t\treturn *this;",
			"\t}",
			"\tMatrix & operator *=(const Matrix & rhs) {",
			"\t\t*this = *this * rhs;",
			"\t\treturn *this;",
			"\t}",
			"\tMatrix & operator /=(const Matrix & rhs) {",
			"\t\t*this *= rhs.inverse();",
			"\t\treturn *this;",
			"\t}",
			"\t",
			"\tMatrix pow(long long n) const {",
			"\t\tMatrix res = identity(h), x(*this);",
			"\t\tif (n < 0) { x = x.inverse(); n = -n; }",
			"\t\twhile (n) { if (n & 1) res *= x; x *= x; n >>= 1; }",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tMatrix trans() const {",
			"\t\tMatrix res(w, h);",
			"\t\tfor (size_type i = 0; i < h; ++i) for (size_type j = 0; j < w; ++j)",
			"\t\t\tres.val[j][i] = val[i][j];",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tMatrix inverse() const {",
			"\t\tassert(is_square());",
			"\t\tMatrix aug_mat = this->hstack(identity(h));",
			"\t\tif (aug_mat.gauss_jordan().first != h) return Matrix();",
			"\t\treturn aug_mat.submat(0, w, h, 2 * w);",
			"\t}",
			"\t",
			"\tMatrix vstack(const Matrix & A) const {",
			"\t\tassert(w == A.w);",
			"\t\tMatrix res(h + A.h, w);",
			"\t\tstd::copy(val.begin(), val.end(), res.val.begin());",
			"\t\tstd::copy(A.val.begin(), A.val.end(), res.val.begin() + h);",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tMatrix hstack(const Matrix & A) const {",
			"\t\tassert(h == A.h);",
			"\t\tMatrix res(h, w + A.w);",
			"\t\tfor (int i = 0; i < h; ++i) {",
			"\t\t\tstd::copy(val[i].begin(), val[i].end(), res.val[i].begin());",
			"\t\t\tstd::copy(A.val[i].begin(), A.val[i].end(), res.val[i].begin() + w);",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tMatrix submat(size_type i1, size_type j1, size_type i2, size_type j2) const {",
			"\t\tassert(i1 < i2 && j1 < j2 && i2 <= h && j2 <= w);",
			"\t\tMatrix res(i2 - i1, j2 - j1);",
			"\t\tfor (size_type i = 0; i < i2 - i1; ++i)",
			"\t\t\tstd::copy(val[i + i1].begin() + j1, val[i + i1].begin() + j2, res.val[i].begin());",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tstatic Matrix identity(size_type n) {",
			"\t\tMatrix res(n, n);",
			"\t\tfor (size_type i = 0; i < n; ++i) res(i, i) = 1;",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tstd::pair<size_type, value_type> gauss_jordan(size_type colnum = -1) {",
			"\t\tif (colnum == -1) colnum = w;",
			"\t\tsize_type rank = 0;",
			"\t\tvalue_type det {};",
			"\t\tbool done = false, rflag = false;",
			"\t\t",
			"\t\tfor (size_type k = 0; k < colnum; ++k) {",
			"\t\t\tsize_type pivot = -1;",
			"\t\t\tfor (size_type i = rank; i < h; ++i) {",
			"\t\t\t\tif (val[i][k] != 0) {",
			"\t\t\t\t\tpivot = i;",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tif (pivot == -1) continue;",
			"\t\t\tif (pivot != rank) {",
			"\t\t\t\trflag ^= 1;",
			"\t\t\t\tstd::swap(val[rank], val[pivot]);",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tif (!done) { det = val[rank][k]; done = true; }",
			"\t\t\telse det *= val[rank][k];",
			"\t\t\t",
			"\t\t\tvalue_type div = static_cast<value_type>(1) / val[rank][k];",
			"\t\t\tfor (size_type j = k; j < w; ++j) val[rank][j] *= div;",
			"\t\t\t",
			"\t\t\tfor (size_type i = 0; i < h; ++i) if (i != rank) {",
			"\t\t\t\tfor (size_type j = k + 1; j < w; ++j) val[i][j] -= val[rank][j] * val[i][k];",
			"\t\t\t\t\tval[i][k] = 0;",
			"\t\t\t}",
			"\t\t\t++rank;",
			"\t\t}",
			"\t\t",
			"\t\tif (!is_square() || rank != h) det = 0;",
			"\t\telse if (rflag) det *= -1;",
			"\t\t",
			"\t\treturn {rank, det};",
			"\t}",
			"\t",
			"\tfriend std::ostream & operator <<(std::ostream & os, const Matrix & rhs) {",
			"\t\tos << \"type = (\" << rhs.h << \",\" << rhs.w << \") [\\n\";",
			"\t\tfor (size_type i = 0; i < rhs.h; ++i) for (size_type j = 0; j < rhs.w; ++j)",
			"\t\t\tos << (j == 0 ? \" \" : \"\") << rhs.val[i][j] << (j + 1 == rhs.w ? '\\n' : ' ');",
			"\t\treturn os << \"]\";",
			"\t}",
			"\t",
			"private:",
			"\tsize_type h, w;",
			"\tstd::vector<std::vector<value_type>> val;",
			"};\n",
		],
		"description": [
			"行列(mint)",
			"https://tkmst201.github.io/Library/Mathematics/Matrix.hpp",
			"2020/04/13"
		]
	},
	
	"FastFourierTransform": {
		"prefix": "FastFourierTransform",
		"body": [
			"struct FastFourierTransform {",
			"public:",
			"\tusing value_type = double;",
			"\tusing size_type = std::size_t;",
			"\tusing complex_type = std::complex<value_type>;",
			"\t",
			"\ttemplate<typename T>",
			"\tstatic std::vector<value_type> multiply(const std::vector<T> &A, const std::vector<T> &B) {",
			"\t\tif (A.empty() || B.empty()) return {};",
			"\t\tsize_type n_ = A.size() + B.size() - 1;",
			"\t\tsize_type n = 1, ni = 0;",
			"\t\twhile (n < n_) n <<= 1, ++ni;",
			"\t\tconst size_type m = n >> 1;",
			"\t\tconst std::vector<complex_type> zeta = _zeta(ni);",
			"\t\t",
			"\t\tstd::vector<complex_type> a;",
			"\t\ta.resize(n);",
			"\t\tfor (size_type i = 0; i < A.size(); ++i) a[i].real(A[i]);",
			"\t\tfor (size_type i = 0; i < B.size(); ++i) a[i].imag(B[i]);",
			"\t\tfft(a, zeta);",
			"\t\t",
			"\t\tstd::vector<complex_type> c;",
			"\t\tc.reserve(m + 1);",
			"\t\tc.emplace_back(a[0].real() * a[0].imag(), 0);",
			"\t\tfor (size_type i = 1; i != m; ++i) {",
			"\t\t\tconst complex_type a_conj = std::conj(a[n - i]);",
			"\t\t\tconst complex_type prod = (a[i] + a_conj) * (a[i] - a_conj) / 4.0;",
			"\t\t\tc.emplace_back(prod.imag(), -prod.real());",
			"\t\t}",
			"\t\tc.emplace_back(a[m].real() * a[m].imag(), 0);",
			"\t\t",
			"\t\ta.resize(m);",
			"\t\tfor (size_type i = 0; i < m; ++i) {",
			"\t\t\tconst complex_type c_conj = std::conj(c[m - i]);",
			"\t\t\tconst complex_type e = (c[i] + c_conj) / 2.0;",
			"\t\t\tconst complex_type o = (c[i] - c_conj) * std::conj(zeta[i]) / 2.0;",
			"\t\t\ta[i] = complex_type(e.real() - o.imag(), -e.imag() - o.real());",
			"\t\t}",
			"\t\tfft(a, zeta);",
			"\t\t",
			"\t\tstd::vector<value_type> res;",
			"\t\tres.reserve(n);",
			"\t\tfor (size_type i = 0; i < m; ++i) {",
			"\t\t\tres.emplace_back(a[i].real() / static_cast<value_type>(m));",
			"\t\t\tres.emplace_back(-a[i].imag() / static_cast<value_type>(m));",
			"\t\t}",
			"\t\tres.resize(A.size() + B.size() - 1);",
			"\t\treturn res;",
			"\t}",
			"\t",
			"private:",
			"\tstatic void fft(std::vector<complex_type> &A, const std::vector<complex_type> &zeta) {",
			"\t\tconst size_type N = A.size();",
			"\t\tconst value_type PI = std::acos(static_cast<value_type>(-1));",
			"\t\t",
			"\t\tsize_type zi = 0;",
			"\t\tfor (size_type i = 1; i < zeta.size(); i <<= 1, ++zi);",
			"\t\t",
			"\t\tbit_reverse(A);",
			"\t\tsize_type n;",
			"\t\tfor (n = 4; n <= N; n <<= 2) {",
			"\t\t\tzi -= 2;",
			"\t\t\tsize_type m = n >> 2;",
			"\t\t\t// \\omega_n^k = zeta[k << zi]",
			"\t\t\tsize_type p;",
			"\t\t\tfor (p = 0; p < N; p += n) {",
			"\t\t\t\tfor (size_type i = p, ei = p + m; i != ei; ++i) {",
			"\t\t\t\t\tcomplex_type a0 = A[i], a2 = A[i + m] * zeta[(i - p) << (zi + 1)];",
			"\t\t\t\t\tcomplex_type a1 = A[i + (m << 1)] * zeta[(i - p) << zi], a3 = A[i + n - m] * zeta[3 * (i - p) << zi];",
			"\t\t\t\t\t",
			"\t\t\t\t\tcomplex_type lp = a0 + a2, ln = a0 - a2;",
			"\t\t\t\t\tcomplex_type rp = a1 + a3, rn = a1 - a3;",
			"\t\t\t\t\tA[i] = lp + rp;",
			"\t\t\t\t\tA[i + m] = complex_type(ln.real() + rn.imag(), ln.imag() - rn.real());",
			"\t\t\t\t\tA[i + (m << 1)] = lp - rp;",
			"\t\t\t\t\tA[i + n - m] = complex_type(ln.real() - rn.imag(), ln.imag() + rn.real());",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\t",
			"\t\tif (n >> 2 < N) {",
			"\t\t\t--zi;",
			"\t\t\tfor (size_type i = 0, m = N >> 1; i != m; ++i) {",
			"\t\t\t\tconst complex_type a = A[i], b = A[i + m] * zeta[i << zi];",
			"\t\t\t\tA[i] = a + b;",
			"\t\t\t\tA[i + m] = a - b;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\tstatic void bit_reverse(std::vector<complex_type> &A) {",
			"\t\tconst size_type N = A.size();",
			"\t\tfor (size_type i = 1, j = 0; i < N - 1; ++i) {",
			"\t\t\tfor (size_type k = N >> 1; k > (j ^= k); k >>= 1);",
			"\t\t\tif (i < j) std::swap(A[i], A[j]);",
			"\t\t}",
			"\t}",
			"\t",
			"\tstatic std::vector<complex_type> _zeta(size_type max_p) {",
			"\t\tconst value_type PI = std::acos(static_cast<value_type>(-1));",
			"\t\t// zeta[j] := \\omega_{2^max_p}^j",
			"\t\tstd::vector<complex_type> zeta;",
			"\t\tzeta.reserve(1 << max_p);",
			"\t\tzeta.emplace_back(1, 0);",
			"\t\tfor (size_type i = 0; i < max_p; ++i) {",
			"\t\t\tconst value_type rad = static_cast<value_type>(-2) * PI / static_cast<value_type>(1 << max_p - i);",
			"\t\t\tzeta.emplace_back(std::polar<value_type>(1, rad));",
			"\t\t\tfor (size_type j = (1 << i) + 1, ej = 1 << i + 1; j != ej; ++j) {",
			"\t\t\t\tzeta.emplace_back(zeta[1 << i ^ j] * zeta[1 << i]);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn zeta;",
			"\t}",
			"};\n",
		],
		"description": [
			"実数の畳み込み",
			"https://tkmst201.github.io/Library/Mathematics/Convolution/FastFourierTransform_Real_CooleyTukey-time-radix4.hpp",
			"2020/11/19"
		]
	},
	
	"TwoSat": {
		"prefix": "TwoSat",
		"body": [
			"struct TwoSat {",
			"\tusing size_type = std::size_t;",
			"\t",
			"private:",
			"\tsize_type n;",
			"\tStronglyConnectedComponents scc;",
			"\tstd::vector<bool> ans;",
			"\tbool isbuilt, satisfiability;",
			"\t",
			"public:",
			"\tTwoSat(size_type n) : n(n), scc(2 * n + 2) {}",
			"\t",
			"\tvoid add_clause(size_type x, bool xb, size_type y, bool yb) {",
			"\t\tassert(x < n);",
			"\t\tassert(y < n);",
			"\t\tscc.add_edge(x + (xb ? n : 0), y + ((yb^1) ? n : 0));",
			"\t\tscc.add_edge(y + (yb ? n : 0), x + ((xb^1) ? n : 0));",
			"\t\tisbuilt = false;",
			"\t}",
			"\t",
			"\tvoid add_clause(size_type x, bool xb) {",
			"\t\tassert(x < n);",
			"\t\tscc.add_edge(x + (xb ? n : 0), 2*n);",
			"\t\tscc.add_edge(x + (xb ? n : 0), 2*n + 1);",
			"\t\tscc.add_edge(2*n, x + ((xb^1) ? n : 0));",
			"\t\tscc.add_edge(2*n + 1, x + ((xb^1) ? n : 0));",
			"\t}",
			"\t",
			"\tbool build() {",
			"\t\tscc.build(false);",
			"\t\tans.assign(n, false);",
			"\t\tsatisfiability = false;",
			"\t\tif (scc.get_rank(2*n) == scc.get_rank(2*n + 1)) return false;",
			"\t\tfor (size_type i = 0; i < n; ++i) {",
			"\t\t\tif (scc.get_rank(i) == scc.get_rank(i + n)) return false;",
			"\t\t\tif (scc.get_rank(i) > scc.get_rank(i + n)) ans[i] = true;",
			"\t\t}",
			"\t\tisbuilt = true;",
			"\t\tsatisfiability = true;",
			"\t\treturn true;",
			"\t}",
			"\t",
			"\tconst std::vector<bool> & get_answer() const {",
			"\t\tassert(isbuilt);",
			"\t\tassert(satisfiability);",
			"\t\treturn ans;",
			"\t}",
			"\t",
			"\tbool get(size_type i) const {",
			"\t\tassert(isbuilt);",
			"\t\tassert(satisfiability);",
			"\t\tassert(i < n);",
			"\t\treturn ans[i];",
			"\t}",
			"};\n",
		],
		"description": [
			"2-SAT ソルバ",
			"StronglyConnectedConponents が必要",
			"https://tkmst201.github.io/Library/Mathematics/TwoSat.hpp",
			"2020/09/10"
		]
	},
	
	"sum_of_floor_of_linear": {
		"prefix": "sum_of_floor_of_linear",
		"body": [
			"namespace tk {",
			"template<typename T>",
			"T sum_of_floor_of_linear(T N, T M, T A, T B) {",
			"\tusing value_type = T;",
			"\tvalue_type res = 0;",
			"\tassert(N >= 0);",
			"\tassert(M > 0);",
			"\tassert(A >= 0);",
			"\tassert(B >= 0);",
			"\t",
			"\tif (B >= M) {",
			"\t\tvalue_type d = B / M;",
			"\t\tres += d * N;",
			"\t\tB -= d * M;",
			"\t}",
			"\tif (N == 0) return res;",
			"\t",
			"\twhile (true) {",
			"\t\tif (A >= M) {",
			"\t\t\tvalue_type d = A / M;",
			"\t\t\tres += N * (N - 1) / 2 * d;",
			"\t\t\tA -= d * M;",
			"\t\t}",
			"\t\tif (A == 0) break;",
			"\t\t",
			"\t\tvalue_type ymax = (A * N + B) / M;",
			"\t\tif (ymax == 0) break;",
			"\t\t",
			"\t\tvalue_type t = M * ymax - B;",
			"\t\tres += ymax * (N - (t + A - 1) / A);",
			"\t\tB = A - t % A;",
			"\t\tif (B == A) B -= A;",
			"\t\tN = ymax;",
			"\t\tstd::swap(A, M);",
			"\t}",
			"\treturn res;",
			"}",
			"} // namespace tk\n",
		],
		"description": [
			"Sum_{i = 0}^{N - 1} floor((A * i + B) / M) を求める",
			"https://tkmst201.github.io/Library/Mathematics/sum_of_floor_of_linear.hpp",
			"2020/09/11"
		]
	},
	
	"Polynomial": {
		"prefix": "Polynomial",
		"body": [
			"namespace tk {",
			"template<typename T>",
			"std::vector<T> linear_prod(const std::vector<T> & poly, T d) {",
			"\tassert(!poly.empty());",
			"\tusing size_type = std::size_t;",
			"\tstd::vector<T> res;",
			"\tres.reserve(poly.size() + 1);",
			"\tres.emplace_back(poly[0] * (static_cast<mint>(0) - d));",
			"\tfor (size_type i = 1; i < poly.size(); ++i)",
			"\t\tres.emplace_back(poly[i - 1] + poly[i] * (static_cast<mint>(0) - d));",
			"\tres.emplace_back(poly.back());",
			"\treturn res;",
			"}",
			"",
			"template<typename T>",
			"std::vector<T> linear_div(const std::vector<T> & poly, T d) {",
			"\tassert(poly.size() >= 2);",
			"\tusing size_type = std::size_t;",
			"\tstd::vector<T> res(poly.size() - 1);",
			"\tT r = 0;",
			"\tfor (size_type i = poly.size() - 1; i > 0; --i) {",
			"\t\tres[i - 1] = r + poly[i];",
			"\t\tr = res[i - 1] * d;",
			"\t}",
			"\tr += poly[0];",
			"\tassert(r == 0);",
			"\treturn res;",
			"}",
			"} // namespace tk\n",
		],
		"description": [
			"多項式と 1 次式の乗除",
			"https://tkmst201.github.io/Library/Mathematics/Polynomial.hpp",
			"2020/11/02"
		]
	},
	
	
	/* String */
	"RollingHash": {
		"prefix": "RollingHash",
		"body": [
			"struct RollingHash {",
			"public:",
			"\tusing size_type = std::size_t;",
			"\tusing string_type = std::string;",
			"\tusing uint64 = std::uint64_t;",
			"\t",
			"private:",
			"\tstatic constexpr uint64 mod = (1ull << 61) - 1;",
			"\tstatic constexpr uint64 mask31 = (1ull << 31) - 1;",
			"\tstatic constexpr uint64 mask30 = (1ull << 30) - 1;",
			"\tstatic constexpr uint64 mask61 = (1ull << 61) - 1;",
			"\t",
			"public:",
			"\tRollingHash(string_type s) {",
			"\t\tif (base().empty()) set_base();",
			"\t\tbuild(s);",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn n;",
			"\t}",
			"\t",
			"\tvoid build(string_type s) {",
			"\t\tn = s.size();",
			"\t\thashv.clear();",
			"\t\tbasep.clear();",
			"\t\tfor (size_type i = 0; i < base().size(); ++i) {",
			"\t\t\thashv.emplace_back();",
			"\t\t\tbasep.emplace_back();",
			"\t\t\thashv[i].emplace_back(0);",
			"\t\t\tbasep[i].emplace_back(1);",
			"\t\t\tfor (size_type j = 0; j < size(); ++j) {",
			"\t\t\t\tuint64 nh = mul(hashv[i].back(), base()[i]) + static_cast<uint64>(s[j]);",
			"\t\t\t\thashv[i].emplace_back(modulo(nh));",
			"\t\t\t\tbasep[i].emplace_back(modulo(mul(basep[i].back(), base()[i])));",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\tuint64 hash(size_type i, size_type l, size_type r) const {",
			"\t\tassert(i < base().size());",
			"\t\tassert(l < r);",
			"\t\tassert(r <= size());",
			"\t\treturn modulo((mod << 2) - mul(hashv[i][l], basep[i][r - l]) + hashv[i][r]);",
			"\t}",
			"\t",
			"\tstd::vector<uint64> hash(size_type l, size_type r) const {",
			"\t\tassert(l < r);",
			"\t\tassert(r <= size());",
			"\t\tstd::vector<uint64> res;",
			"\t\tfor (size_type i = 0; i < base().size(); ++i) res.emplace_back(hash(i, l, r));",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tbool match(size_type l1, size_type r1, size_type l2, size_type r2) const {",
			"\t\tassert(l1 < r1);",
			"\t\tassert(r1 <= size());",
			"\t\tassert(l2 < r2);",
			"\t\tassert(r2 <= size());",
			"\t\tfor (size_type i = 0; i < base().size(); ++i) if (hash(i, l1, r1) != hash(i, l2, r2)) return false;",
			"\t\treturn true;",
			"\t}",
			"\t",
			"private:",
			"\tsize_type n;",
			"\tstd::vector<std::vector<uint64>> basep;",
			"\tstd::vector<std::vector<uint64>> hashv; // [i][j] := hash(s[0..j-1]), use base[i]",
			"\t",
			"\tstatic std::vector<uint64> & base() {",
			"\t\tstatic std::vector<uint64> base_;",
			"\t\treturn base_;",
			"\t}",
			"\t",
			"\tstatic void set_base() {",
			"\t\tbase().emplace_back(100000001111);",
			"\t\t// base().emplace_back(100000011200);",
			"\t\t// base().emplace_back(100000011000);",
			"\t\t// base().emplace_back(100000014848);",
			"\t\t// base().emplace_back(100000015050);",
			"\t\t",
			"\t\tauto rnd = std::bind(std::uniform_int_distribution<uint64>(2, mod - 2), std::mt19937_64(std::random_device{}()));",
			"\t\tconstexpr size_type gen_cnt = 1;",
			"\t\tfor (size_type i = 0; i < gen_cnt; ++i) {",
			"\t\t\twhile (true) {",
			"\t\t\t\tuint64 k = rnd();",
			"\t\t\t\tif (gcd(k, mod - 1) != 1) continue;",
			"\t\t\t\tuint64 cur = mod_pow(base()[0], k);",
			"\t\t\t\tif (cur < 10000000000) continue;",
			"\t\t\t\tbase().emplace_back(cur);",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\t// x, y < mod => res < (mod << 2)",
			"\tstatic uint64 mul(uint64 x, uint64 y) {",
			"\t\tconst uint64 xu = x >> 31, xd = x & mask31;",
			"\t\tconst uint64 yu = y >> 31, yd = y & mask31;",
			"\t\tconst uint64 t = xu * yd + yu * xd;",
			"\t\tuint64 res = (xu * yu) << 1;",
			"\t\tres += (t >> 30) + ((t & mask30) << 31);",
			"\t\tres += xd * yd;",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tstatic uint64 modulo(uint64 x) {",
			"\t\tconst uint64 sum = (x >> 61) + (x & mask61);",
			"\t\treturn sum < mod ? sum : sum - mod;",
			"\t}",
			"\t",
			"\tstatic uint64 mod_pow(uint64 x, uint64 n) {",
			"\t\tif (n == 0) return 1;",
			"\t\tuint64 res = mod_pow(modulo(mul(x, x)), n >> 1);",
			"\t\tif (n & 1) res = modulo(mul(res, x));",
			"\t\treturn res;",
			"\t}",
			"\t",
			"\tstatic uint64 gcd(uint64 x, uint64 y) {",
			"\t\twhile (y > 0) {",
			"\t\t\tuint64 t = y;",
			"\t\t\ty = x % y;",
			"\t\t\tx = t;",
			"\t\t}",
			"\t\treturn x;",
			"\t}",
			"};\n",
		],
		"description": [
			"ローリングハッシュ",
			"https://tkmst201.github.io/Library/String/RollingHash.hpp",
			"2020/08/22"
		]
	},
	
	"SuffixArray": {
		"prefix": "SuffixArray",
		"body": [
			"struct SuffixArray {",
			"\tusing size_type = std::size_t;",
			"\tusing string_type = std::string;",
			"\t",
			"\tSuffixArray(string_type s) {",
			"\t\tbuild(s);",
			"\t}",
			"\t",
			"\tsize_type size() const noexcept {",
			"\t\treturn s.size();",
			"\t}",
			"\t",
			"\tconst size_type & operator[](size_type i) const noexcept {",
			"\t\treturn sa[i];",
			"\t}",
			"\t",
			"\tconst size_type & at(size_type i) const {",
			"\t\tassert(i <= size());",
			"\t\treturn (*this)[i];",
			"\t}",
			"\t",
			"\tconst std::vector<size_type> & get_sa() const noexcept {",
			"\t\treturn sa;",
			"\t}",
			"\t",
			"\tconst std::vector<size_type> & get_lcp() const noexcept {",
			"\t\treturn lcp;",
			"\t}",
			"\t",
			"\tvoid build(string_type s) {",
			"\t\tthis->s = s;",
			"\t\tsa = sa_is(s);",
			"\t\trank.resize(size() + 1);",
			"\t\tfor (size_type i = 0; i <= size(); ++i) rank[sa[i]] = i;",
			"\t\t",
			"\t\t// LCP 配列の構築",
			"\t\tlcp.resize(size());",
			"\t\tlcp[0] = 0;",
			"\t\tsize_type mtc = 0;",
			"\t\t// lcp[i] := lcp(s[sa[i]], s[sa[i + 1])",
			"\t\tfor (size_type i = 0; i < size(); ++i) {",
			"\t\t\t// lcp[rank[i]] = lcp(s[i..], s[sa[rank[i] + 1])",
			"\t\t\tif (rank[i] == size()) continue;",
			"\t\t\tsize_type k = sa[rank[i] + 1];",
			"\t\t\twhile (i + mtc < size() && k + mtc < size() && s[i + mtc] == s[k + mtc]) ++mtc;",
			"\t\t\tlcp[rank[i]] = mtc;",
			"\t\t\tif (mtc > 0) --mtc;",
			"\t\t}",
			"\t\t",
			"\t\t// セグ木の初期化",
			"\t\tseg_n = 1;",
			"\t\twhile (seg_n < size() + 1) seg_n <<= 1;",
			"\t\tseg.resize(seg_n << 1);",
			"\t\tfor (size_type i = 0; i < size(); ++i) seg[i + seg_n] = lcp[i];",
			"\t\tfor (size_type i = size(); i < seg_n; ++i) seg[i + seg_n] = 0;",
			"\t\tfor (size_type i = seg_n - 1; i > 0; --i) seg[i] = std::min(seg[i << 1], seg[i << 1 | 1]);",
			"\t\t",
			"\t\t// debug 出力",
			"\t\t// for (size_type i = 0; i <= size(); ++i) {",
			"\t\t// \tstd::cout << \"sa[\" << i << \"] = \" << sa[i] << \"\\t, s[sa[i]..] = \" << s.substr(sa[i]);",
			"\t\t// \tif (i < size()) std::cout << \"\\t\\t\\t lcp[i] = \" << lcp[i];",
			"\t\t// \tstd::cout << std::endl;",
			"\t\t// }",
			"\t}",
			"\t",
			"\ttemplate<class S>",
			"\tstatic std::vector<size_type> sa_is(S s, const size_type kind = 128) {",
			"\t\tsize_type n = s.size();",
			"\t\tfor (size_type i = 0; i < n; ++i) ++s[i];",
			"\t\ts.push_back(0);",
			"\t\t",
			"\t\tstd::vector<bool> Stype(n + 1); // true: S-type, false: L-type",
			"\t\tstd::vector<size_type> lms; // LMS-index",
			"\t\tstd::vector<size_type> lms_map(n + 1, n + 1); // [i] := もし i が LMS-index なら lms 配列の index, 違えば n + 1",
			"\t\tstd::vector<size_type> bin(kind + 2); // [i] := count_{j < i} (s[j] = j) => count(s[i] = i]) = bin[i + 1] - bin[i]",
			"\t\t++bin[1];",
			"\t\t",
			"\t\tStype[n] = true;",
			"\t\tfor (size_type i = n; i > 0; --i) {",
			"\t\t\tStype[i - 1] = s[i - 1] == s[i] ? Stype[i] : s[i - 1] < s[i];",
			"\t\t\t++bin[s[i - 1] + 1];",
			"\t\t}",
			"\t\tfor (size_type i = 1; i <= n; ++i) {",
			"\t\t\tif (!Stype[i - 1] && Stype[i]) {",
			"\t\t\t\tlms_map[i] = lms.size();",
			"\t\t\t\tlms.emplace_back(i);",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor (size_type i = 0; i < kind + 1; ++i) bin[i + 1] += bin[i];",
			"\t\t",
			"\t\tstd::vector<size_type> sa, cnt;",
			"\t\t",
			"\t\tauto induce = [&](const std::vector<size_type> &lms) {",
			"\t\t\tsa.assign(n + 1, 0);",
			"\t\t\t",
			"\t\t\tcnt.assign(kind + 1, 0);",
			"\t\t\tfor (size_type i = lms.size(); i > 0; --i) {",
			"\t\t\t\tconst size_type idx = lms[i - 1];",
			"\t\t\t\tconst size_type c = s[idx];",
			"\t\t\t\tsa[bin[c + 1] - cnt[c] - 1] = idx;",
			"\t\t\t\t++cnt[c];",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tcnt.assign(kind + 1, 0);",
			"\t\t\tfor (size_type i = 0; i < n; ++i) {",
			"\t\t\t\tif (sa[i] == 0) continue;",
			"\t\t\t\tconst size_type idx = sa[i] - 1;",
			"\t\t\t\tif (!Stype[idx]) {",
			"\t\t\t\t\tconst size_type c = s[idx];",
			"\t\t\t\t\tsa[bin[c] + cnt[c]] = idx;",
			"\t\t\t\t\t++cnt[c];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tcnt.assign(kind + 1, 0);",
			"\t\t\tfor (size_type i = n; i > 0; --i) {",
			"\t\t\t\tif (sa[i] == 0) continue;",
			"\t\t\t\tconst size_type idx = sa[i] - 1;",
			"\t\t\t\tif (Stype[idx]) {",
			"\t\t\t\t\tconst size_type c = s[idx];",
			"\t\t\t\t\tsa[bin[c + 1] - 1 - cnt[c]] = idx;",
			"\t\t\t\t\t++cnt[c];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t};",
			"\t\t",
			"\t\tinduce(lms);",
			"\t\t",
			"\t\tif (lms.size() >= 2) {",
			"\t\t\tstd::vector<size_type> lms_str(lms.size() - 1); // [i] := lms の index i が何番目(0-indexed) に小さいか(\"\\$\" は無視)",
			"\t\t\tsize_type pre = lms[lms_map[sa[0]]], pre_len = 1, rank = 0;",
			"\t\t\tfor (size_type i = 1; i <= n; ++i) {",
			"\t\t\t\tconst size_type lms_idx = lms_map[sa[i]]; // sa[i] が LMS なら lms の index, 違えば n + 1",
			"\t\t\t\tif (lms_idx == n + 1) continue;",
			"\t\t\t\tconst size_type idx = lms[lms_map[sa[i]]];",
			"\t\t\t\tconst size_type len = lms[lms_idx + 1] - idx + 1;",
			"\t\t\t\t",
			"\t\t\t\t// LMS-substring の s[pre..] と s[idx..] を比較",
			"\t\t\t\tbool issame = pre_len == len;",
			"\t\t\t\tif (issame) {",
			"\t\t\t\t\tfor (size_type j = 0; j < len; ++j) {",
			"\t\t\t\t\t\tif (s[pre + j] != s[idx + j]) {",
			"\t\t\t\t\t\t\tissame = false;",
			"\t\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\trank += !issame;",
			"\t\t\t\tlms_str[lms_idx] = rank - 1;",
			"\t\t\t\t",
			"\t\t\t\tpre = idx;",
			"\t\t\t\tpre_len = len;",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tstd::vector<size_type> new_seed(lms.size());",
			"\t\t\tnew_seed[0] = sa[0];",
			"\t\t\t",
			"\t\t\tif (rank == lms_str.size()) {",
			"\t\t\t\tfor (size_type i = 0; i < lms_str.size(); ++i) new_seed[lms_str[i] + 1] = lms[i];",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tstd::vector<size_type> lms_sa = sa_is(lms_str, rank);",
			"\t\t\t\tfor (size_type i = 1; i < lms_sa.size(); ++i) new_seed[i] = lms[lms_sa[i]];",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tinduce(new_seed);",
			"\t\t}",
			"\t\t",
			"\t\treturn sa;",
			"\t}",
			"\t",
			"\tstd::pair<size_type, size_type> lower_bound(string_type p) const {",
			"\t\tsize_type l = 0, r = seg_n;",
			"\t\tsize_type lplcp = 0, rplcp = 0;",
			"\t\tsize_type seg_idx = 1;",
			"\t\t",
			"\t\twhile (r - l > 1) {",
			"\t\t\tconst size_type m = (l + r) >> 1;",
			"\t\t\tconst size_type lmlcp = seg[seg_idx << 1];",
			"\t\t\tconst size_type rmlcp = seg[seg_idx << 1 | 1];",
			"\t\t\t// std::cout << \"(l, r] = (\" << l << \", \" << r << \"], m = \" << m << \" : lplcp = \" << lplcp << \", rplcp = \" << rplcp << \", lmlcp = \" << lmlcp << \", rmlcp = \" << rmlcp << std::endl;",
			"\t\t\tbool move_r;",
			"\t\t\t",
			"\t\t\tif (lplcp < lmlcp) {",
			"\t\t\t\tmove_r = true;",
			"\t\t\t}",
			"\t\t\telse if (lplcp > lmlcp) {",
			"\t\t\t\tmove_r = false;",
			"\t\t\t\trplcp = lmlcp;",
			"\t\t\t}",
			"\t\t\telse if (rplcp < rmlcp) {",
			"\t\t\t\tmove_r = false;",
			"\t\t\t}",
			"\t\t\telse if (rplcp > rmlcp) {",
			"\t\t\t\tmove_r = true;",
			"\t\t\t\tlplcp = rmlcp;",
			"\t\t\t}",
			"\t\t\telse if (m > size()) {",
			"\t\t\t\tmove_r = false;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\tsize_type mplcp = lplcp;",
			"\t\t\t\twhile (sa[m] + mplcp < size() && mplcp < p.size() && s[sa[m] + mplcp] == p[mplcp]) ++mplcp;",
			"\t\t\t\t",
			"\t\t\t\tif (mplcp == p.size() || sa[m] + mplcp < size() && s[sa[m] + mplcp] > p[mplcp]) move_r = false;",
			"\t\t\t\telse move_r = true;",
			"\t\t\t\t(move_r ? lplcp : rplcp) = mplcp;",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tseg_idx <<= 1;",
			"\t\t\tif (move_r) {",
			"\t\t\t\tl = m;",
			"\t\t\t\tseg_idx |= 1;",
			"\t\t\t}",
			"\t\t\telse r = m;",
			"\t\t}",
			"\t\tif (r > size()) r = size() + 1;",
			"\t\treturn {r, rplcp};",
			"\t}",
			"\t",
			"\tsize_type search(string_type p) const {",
			"\t\tconst auto lb = lower_bound(p);",
			"\t\treturn lb.second < p.size() ? size() : sa[lb.first];",
			"\t}",
			"\t",
			"\tstd::vector<size_type> search_all(string_type p) const {",
			"\t\tconst auto lb = lower_bound(p);",
			"\t\tif (lb.second < p.size()) return {};",
			"\t\tsize_type idx = lb.first;",
			"\t\tstd::vector<size_type> res;",
			"\t\tres.emplace_back(sa[idx++]);",
			"\t\tfor (; idx <= size() && lcp[idx - 1] >= p.size(); ++idx) res.emplace_back(sa[idx]);",
			"\t\treturn res;",
			"\t}",
			"\t",
			"private:",
			"\tstring_type s;",
			"\tstd::vector<size_type> sa; // sa[i (<= |s|)] := i 番目に小さい suffix の先頭 index",
			"\tstd::vector<size_type> rank; // [i (<= |s|)] := s[i..] が suffix の中で rank[i] 番目(0-indexed) に小さい",
			"\tstd::vector<size_type> lcp; // [i (< size())] := lcp(s[sa[i]..], s[sa[i + 1]..])",
			"\tsize_type seg_n;",
			"\tstd::vector<size_type> seg;",
			"};\n",
		],
		"description": [
			"SuffixArray(SA-IS, LCP)",
			"https://tkmst201.github.io/Library/String/SuffixArray.hpp",
			"2020/08/25"
		]
	},
}